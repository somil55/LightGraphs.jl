{
    "docs": [
        {
            "location": "/", 
            "text": "LightGraphs\n\n\n \n \n \n\n\n \n \n \n\n\nAn optimized graphs package.\n\n\nSimple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.\n\n\nThe project goal is to mirror the functionality of robust network and graph analysis libraries such as \nNetworkX\n while being simpler to use and more efficient than existing Julian graph libraries such as \nGraphs.jl\n. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.\n\n\nAdditional functionality may be found in the companion package \nLightGraphsExtras.jl\n.\n\n\n\n\nDocumentation\n\n\nFull documentation is available at \nGitHub Pages\n. Documentation for methods is also available via the Julia REPL help system. Additional tutorials can be found at \nJuliaGraphsTutorials\n.\n\n\n\n\nCore Concepts\n\n\nA graph \nG\n is described by a set of vertices \nV\n and edges \nE\n: \nG = {V, E}\n. \nV\n is an integer range \n1:n\n; \nE\n is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields \nEdge\n types containing \n(src\n:Integer, dst\n:Integer)\n values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.\n\n\nLightGraphs.jl\n provides two graph types: \nGraph\n is an undirected graph, and \nDiGraph\n is its directed counterpart.\n\n\nGraphs are created using \nGraph()\n or \nDiGraph()\n; there are several options (see the tutorials for examples).\n\n\nMultiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.\n\n\n\n\nInstallation\n\n\nInstallation is straightforward:\n\n\njulia\n Pkg.add(\nLightGraphs\n)\n\n\n\n\n\n\nCurrent functionality\n\n\n\n\ncore functions:\n vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)\n\n\ndistance within graphs:\n eccentricity, diameter, periphery, radius, center\n\n\ndistance between graphs:\n spectral_distance, edit_distance\n\n\nconnectivity:\n strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood\n\n\noperators:\n complement, reverse, reverse!, union, join, intersect, difference,\n\n\n\n\nsymmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)\n\n\n\n\nshortest paths:\n Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\n\n\nsmall graph generators:\n see \nsmallgraphs.jl\n for list\n\n\nrandom graph generators:\n Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model\n\n\ncentrality:\n betweenness, closeness, degree, pagerank, Katz\n\n\ntraversal operations:\n cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\n\n\nflow operations:\n maximum flow\n\n\nmatching:\n Matching functions have been moved to \nLightGraphsExtras.jl\n.\n\n\nclique enumeration:\n maximal cliques\n\n\nlinear algebra / spectral graph theory:\n adjacency matrix (works as input to \nGraphLayout\n and \nMetis\n), Laplacian matrix, non-backtracking matrix\n\n\ncommunity:\n modularity, community detection, core-periphery, clustering coefficients\n\n\npersistence formats:\n proprietary compressed, \nGraphML\n, \nGML\n, \nGexf\n, \nDOT\n, \nPajek NET\n, \nGraph6\n\n\nvisualization:\n integration with\n\n\n\n\nGraphPlot\n, \nPlots\n via \nPlotRecipes\n, \nGraphLayout\n, \nTikzGraphs\n,  \nNetworkViz\n\n\n\n\nCore API\n\n\nThese functions are defined as the public contract of the \nLightGraphs.AbstractGraph\n interface.\n\n\n\n\nConstructing and modifying the graph\n\n\n\n\nGraph\n\n\nDiGraph\n\n\nadd_edge!\n\n\nrem_edge!\n\n\nadd_vertex!\n, \nadd_vertices!\n\n\nrem_vertex!\n\n\nzero\n\n\n\n\n\n\nEdge/Arc interface\n\n\n\n\nsrc\n\n\ndst\n\n\nreverse\n\n\n==\n\n\nPair / Tuple conversion\n\n\n\n\n\n\nAccessing state\n\n\n\n\nnv\n\n\nne\n\n\nvertices\n (Iterable)\n\n\nedges\n (Iterable)\n\n\nneighbors\n, \nin_neighbors\n, \nout_neighbors\n\n\nin_edges\n\n\nout_edges\n\n\nhas_vertex\n\n\nhas_edge\n\n\nhas_self_loops\n (though this might be a trait or an abstract graph type)\n\n\n\n\n\n\nNon-Core APIs\n\n\nThese functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.\n\n\n\n\nadjacency_matrix\n\n\ndegree\n\n\n\n\nThis can be computed from neighbors by default \ndegree(g,v) = length(neighbors(g,v))\n so you don't need to implement this unless your type can compute degree faster than this method.\n\n\n\n\nSupported Versions\n\n\n\n\nLightGraphs master is designed to work with the latest stable version of Julia.\n\n\nJulia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.\n\n\nJulia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.\n\n\nJulia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.\n\n\nJulia 0.6: LightGraphs versions in the 0.8 series are designed to work with Julia 0.6.\n\n\nLater versions: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem, please file an issue.\n\n\n\n\n\n\nContributing and Reporting Bugs\n\n\nWe welcome contributions and bug reports! Please see \nCONTRIBUTING.md\n for guidance on development and bug reporting.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#lightgraphs", 
            "text": "An optimized graphs package.  Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge iterators. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.  The project goal is to mirror the functionality of robust network and graph analysis libraries such as  NetworkX  while being simpler to use and more efficient than existing Julian graph libraries such as  Graphs.jl . It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.  Additional functionality may be found in the companion package  LightGraphsExtras.jl .", 
            "title": "LightGraphs"
        }, 
        {
            "location": "/#documentation", 
            "text": "Full documentation is available at  GitHub Pages . Documentation for methods is also available via the Julia REPL help system. Additional tutorials can be found at  JuliaGraphsTutorials .", 
            "title": "Documentation"
        }, 
        {
            "location": "/#core-concepts", 
            "text": "A graph  G  is described by a set of vertices  V  and edges  E :  G = {V, E} .  V  is an integer range  1:n ;  E  is represented as forward (and, for directed graphs, backward) adjacency lists indexed by vertices. Edges may also be accessed via an iterator that yields  Edge  types containing  (src :Integer, dst :Integer)  values. Both vertices and edges may be integers of any type, and the smallest type that fits the data is recommended in order to save memory.  LightGraphs.jl  provides two graph types:  Graph  is an undirected graph, and  DiGraph  is its directed counterpart.  Graphs are created using  Graph()  or  DiGraph() ; there are several options (see the tutorials for examples).  Multiple edges between two given vertices are not allowed: an attempt to add an edge that already exists in a graph will result in a silent failure.", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/#installation", 
            "text": "Installation is straightforward:  julia  Pkg.add( LightGraphs )", 
            "title": "Installation"
        }, 
        {
            "location": "/#current-functionality", 
            "text": "core functions:  vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)  distance within graphs:  eccentricity, diameter, periphery, radius, center  distance between graphs:  spectral_distance, edit_distance  connectivity:  strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood  operators:  complement, reverse, reverse!, union, join, intersect, difference,   symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)   shortest paths:  Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*  small graph generators:  see  smallgraphs.jl  for list  random graph generators:  Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model  centrality:  betweenness, closeness, degree, pagerank, Katz  traversal operations:  cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks  flow operations:  maximum flow  matching:  Matching functions have been moved to  LightGraphsExtras.jl .  clique enumeration:  maximal cliques  linear algebra / spectral graph theory:  adjacency matrix (works as input to  GraphLayout  and  Metis ), Laplacian matrix, non-backtracking matrix  community:  modularity, community detection, core-periphery, clustering coefficients  persistence formats:  proprietary compressed,  GraphML ,  GML ,  Gexf ,  DOT ,  Pajek NET ,  Graph6  visualization:  integration with   GraphPlot ,  Plots  via  PlotRecipes ,  GraphLayout ,  TikzGraphs ,   NetworkViz", 
            "title": "Current functionality"
        }, 
        {
            "location": "/#core-api", 
            "text": "These functions are defined as the public contract of the  LightGraphs.AbstractGraph  interface.", 
            "title": "Core API"
        }, 
        {
            "location": "/#constructing-and-modifying-the-graph", 
            "text": "Graph  DiGraph  add_edge!  rem_edge!  add_vertex! ,  add_vertices!  rem_vertex!  zero", 
            "title": "Constructing and modifying the graph"
        }, 
        {
            "location": "/#edgearc-interface", 
            "text": "src  dst  reverse  ==  Pair / Tuple conversion", 
            "title": "Edge/Arc interface"
        }, 
        {
            "location": "/#accessing-state", 
            "text": "nv  ne  vertices  (Iterable)  edges  (Iterable)  neighbors ,  in_neighbors ,  out_neighbors  in_edges  out_edges  has_vertex  has_edge  has_self_loops  (though this might be a trait or an abstract graph type)", 
            "title": "Accessing state"
        }, 
        {
            "location": "/#non-core-apis", 
            "text": "These functions can be constructed from the Core API functions but can be given specialized implementations in order to improve performance.   adjacency_matrix  degree   This can be computed from neighbors by default  degree(g,v) = length(neighbors(g,v))  so you don't need to implement this unless your type can compute degree faster than this method.", 
            "title": "Non-Core APIs"
        }, 
        {
            "location": "/#supported-versions", 
            "text": "LightGraphs master is designed to work with the latest stable version of Julia.  Julia 0.3: LightGraphs v0.3.7 is the last version guaranteed to work with Julia 0.3.  Julia 0.4: LightGraphs versions in the 0.6 series are designed to work with Julia 0.4.  Julia 0.5: LightGraphs versions in the 0.7 series are designed to work with Julia 0.5.  Julia 0.6: LightGraphs versions in the 0.8 series are designed to work with Julia 0.6.  Later versions: Some functionality might not work with prerelease / unstable / nightly versions of Julia. If you run into a problem, please file an issue.", 
            "title": "Supported Versions"
        }, 
        {
            "location": "/#contributing-and-reporting-bugs", 
            "text": "We welcome contributions and bug reports! Please see  CONTRIBUTING.md  for guidance on development and bug reporting.", 
            "title": "Contributing and Reporting Bugs"
        }, 
        {
            "location": "/basicmeasures/", 
            "text": "Basic Functions\n\n\nLightGraphs.jl\n defines the following basic types and functionalities:\n\n\n\n\nLightGraphs.add_vertices!\n\n\nLightGraphs.all_neighbors\n\n\nLightGraphs.common_neighbors\n\n\nLightGraphs.degree\n\n\nLightGraphs.degree_histogram\n\n\nLightGraphs.density\n\n\nLightGraphs.has_self_loops\n\n\nLightGraphs.indegree\n\n\nLightGraphs.is_ordered\n\n\nLightGraphs.isgraphical\n\n\nLightGraphs.neighborhood\n\n\nLightGraphs.neighbors\n\n\nLightGraphs.num_self_loops\n\n\nLightGraphs.outdegree\n\n\nLightGraphs.squash\n\n\nLightGraphs.\u0394\n\n\nLightGraphs.\u0394in\n\n\nLightGraphs.\u0394out\n\n\nLightGraphs.\u03b4\n\n\nLightGraphs.\u03b4in\n\n\nLightGraphs.\u03b4out\n\n\n\n\n#\n\n\nLightGraphs.add_vertices!\n \n \nMethod\n.\n\n\nadd_vertices!(g, n)\n\n\n\n\nAdd \nn\n new vertices to the graph \ng\n. Return \ntrue\n if all vertices were added successfully, \nfalse\n otherwise.\n\n\nsource\n\n\n#\n\n\nLightGraphs.all_neighbors\n \n \nFunction\n.\n\n\nall_neighbors(g, v)\n\n\n\n\nReturn a list of all inbound and outbound neighbors of \nv\n in \ng\n. For undirected graphs, this is equivalent to both \nout_neighbors\n and \nin_neighbors\n.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.common_neighbors\n \n \nMethod\n.\n\n\ncommon_neighbors(g, u, v)\n\n\n\n\nReturn the neighbors common to vertices \nu\n and \nv\n in \ng\n.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree\n \n \nFunction\n.\n\n\ndegree(g[, v])\n\n\n\n\nReturn a vector corresponding to the number of edges which start or end at each vertex in graph \ng\n. If \nv\n is specified, only return degrees for vertices in \nv\n. For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree_histogram\n \n \nMethod\n.\n\n\ndegree_histogram(g)\n\n\n\n\nReturn a \nStatsBase.Histogram\n of the degrees of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.density\n \n \nFunction\n.\n\n\ndensity(g)\n\n\n\n\nReturn the density of \ng\n. Density is defined as the ratio of the number of actual edges to the number of possible edges ($|V|\u00d7(|V|-1)$ for directed graphs and $\\frac{|V|\u00d7(|V|-1)}{2}$ for undirected graphs).\n\n\nsource\n\n\n#\n\n\nLightGraphs.has_self_loops\n \n \nMethod\n.\n\n\nhas_self_loops(g)\n\n\n\n\nReturn true if \ng\n has any self loops.\n\n\nsource\n\n\n#\n\n\nLightGraphs.indegree\n \n \nMethod\n.\n\n\nindegree(g[, v])\n\n\n\n\nReturn a vector corresponding to the number of edges which end at each vertex in graph \ng\n. If \nv\n is specified, only return degrees for vertices in \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.is_ordered\n \n \nMethod\n.\n\n\nis_ordered(e)\n\n\n\n\nReturn true if the source vertex of edge \ne\n is less than or equal to the destination vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.neighbors\n \n \nMethod\n.\n\n\nneighbors(g, v)\n\n\n\n\nReturn a list of all neighbors reachable from vertex \nv\n in \ng\n. For directed graphs, the default is equivalent to \nout_neighbors\n; use \nall_neighbors\n to list inbound and outbound neighbors.\n\n\nImplementation Notes\n\n\nReturns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nLightGraphs.num_self_loops\n \n \nMethod\n.\n\n\nnum_self_loops(g)\n\n\n\n\nReturn the number of self loops in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.outdegree\n \n \nMethod\n.\n\n\noutdegree(g[, v])\n\n\n\n\nReturn a vector corresponding to the number of edges which start at each vertex in graph \ng\n. If \nv\n is specified, only return degrees for vertices in \nv\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.squash\n \n \nMethod\n.\n\n\nsquash(g)\n\n\n\n\nReturn a copy of a graph with the smallest practical type that can accommodate all vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394\n \n \nMethod\n.\n\n\n\u0394(g)\n\n\n\n\nReturn the maximum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394in\n \n \nMethod\n.\n\n\n\u0394in(g)\n\n\n\n\nReturn the maximum \nindegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u0394out\n \n \nMethod\n.\n\n\n\u0394out(g)\n\n\n\n\nReturn the maximum \noutdegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4\n \n \nMethod\n.\n\n\n\u03b4(g)\n\n\n\n\nReturn the minimum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4in\n \n \nMethod\n.\n\n\n\u03b4in(g)\n\n\n\n\nReturn the minimum \nindegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.\u03b4out\n \n \nMethod\n.\n\n\n\u03b4out(g)\n\n\n\n\nReturn the minimum \noutdegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.isgraphical\n \n \nMethod\n.\n\n\nisgraphical(degs)\n\n\n\n\nReturn true if the degree sequence \ndegs\n is graphical, according to \nErd\u00f6s-Gallai condition\n.\n\n\nPerformance\n\n\nTime complexity: ``\\mathcal{O}(|degs|^2)``\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.neighborhood\n \n \nMethod\n.\n\n\nneighborhood(g, v, d)\n\n\n\n\nReturn a vector of the vertices in \ng\n at a geodesic distance less or equal to \nd\n from \nv\n.\n\n\nOptional Arguments\n\n\n\n\ndir=:out\n: If \ng\n is directed, this argument specifies the edge direction\n\n\n\n\nwith respect to \nv\n of the edges to be considered. Possible values: \n:in\n or \n:out\n.\n\n\nsource", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/basicmeasures/#basic-functions", 
            "text": "LightGraphs.jl  defines the following basic types and functionalities:   LightGraphs.add_vertices!  LightGraphs.all_neighbors  LightGraphs.common_neighbors  LightGraphs.degree  LightGraphs.degree_histogram  LightGraphs.density  LightGraphs.has_self_loops  LightGraphs.indegree  LightGraphs.is_ordered  LightGraphs.isgraphical  LightGraphs.neighborhood  LightGraphs.neighbors  LightGraphs.num_self_loops  LightGraphs.outdegree  LightGraphs.squash  LightGraphs.\u0394  LightGraphs.\u0394in  LightGraphs.\u0394out  LightGraphs.\u03b4  LightGraphs.\u03b4in  LightGraphs.\u03b4out   #  LightGraphs.add_vertices!     Method .  add_vertices!(g, n)  Add  n  new vertices to the graph  g . Return  true  if all vertices were added successfully,  false  otherwise.  source  #  LightGraphs.all_neighbors     Function .  all_neighbors(g, v)  Return a list of all inbound and outbound neighbors of  v  in  g . For undirected graphs, this is equivalent to both  out_neighbors  and  in_neighbors .  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.common_neighbors     Method .  common_neighbors(g, u, v)  Return the neighbors common to vertices  u  and  v  in  g .  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.degree     Function .  degree(g[, v])  Return a vector corresponding to the number of edges which start or end at each vertex in graph  g . If  v  is specified, only return degrees for vertices in  v . For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.  source  #  LightGraphs.degree_histogram     Method .  degree_histogram(g)  Return a  StatsBase.Histogram  of the degrees of vertices in  g .  source  #  LightGraphs.density     Function .  density(g)  Return the density of  g . Density is defined as the ratio of the number of actual edges to the number of possible edges ($|V|\u00d7(|V|-1)$ for directed graphs and $\\frac{|V|\u00d7(|V|-1)}{2}$ for undirected graphs).  source  #  LightGraphs.has_self_loops     Method .  has_self_loops(g)  Return true if  g  has any self loops.  source  #  LightGraphs.indegree     Method .  indegree(g[, v])  Return a vector corresponding to the number of edges which end at each vertex in graph  g . If  v  is specified, only return degrees for vertices in  v .  source  #  LightGraphs.is_ordered     Method .  is_ordered(e)  Return true if the source vertex of edge  e  is less than or equal to the destination vertex.  source  #  LightGraphs.neighbors     Method .  neighbors(g, v)  Return a list of all neighbors reachable from vertex  v  in  g . For directed graphs, the default is equivalent to  out_neighbors ; use  all_neighbors  to list inbound and outbound neighbors.  Implementation Notes  Returns a reference, not a copy. Do not modify result.  source  #  LightGraphs.num_self_loops     Method .  num_self_loops(g)  Return the number of self loops in  g .  source  #  LightGraphs.outdegree     Method .  outdegree(g[, v])  Return a vector corresponding to the number of edges which start at each vertex in graph  g . If  v  is specified, only return degrees for vertices in  v .  source  #  LightGraphs.squash     Method .  squash(g)  Return a copy of a graph with the smallest practical type that can accommodate all vertices.  source  #  LightGraphs.\u0394     Method .  \u0394(g)  Return the maximum  degree  of vertices in  g .  source  #  LightGraphs.\u0394in     Method .  \u0394in(g)  Return the maximum  indegree  of vertices in  g .  source  #  LightGraphs.\u0394out     Method .  \u0394out(g)  Return the maximum  outdegree  of vertices in  g .  source  #  LightGraphs.\u03b4     Method .  \u03b4(g)  Return the minimum  degree  of vertices in  g .  source  #  LightGraphs.\u03b4in     Method .  \u03b4in(g)  Return the minimum  indegree  of vertices in  g .  source  #  LightGraphs.\u03b4out     Method .  \u03b4out(g)  Return the minimum  outdegree  of vertices in  g .  source  #  LightGraphs.isgraphical     Method .  isgraphical(degs)  Return true if the degree sequence  degs  is graphical, according to  Erd\u00f6s-Gallai condition .  Performance  Time complexity: ``\\mathcal{O}(|degs|^2)``  source  #  LightGraphs.neighborhood     Method .  neighborhood(g, v, d)  Return a vector of the vertices in  g  at a geodesic distance less or equal to  d  from  v .  Optional Arguments   dir=:out : If  g  is directed, this argument specifies the edge direction   with respect to  v  of the edges to be considered. Possible values:  :in  or  :out .  source", 
            "title": "Basic Functions"
        }, 
        {
            "location": "/operators/", 
            "text": "Operators\n\n\nLightGraphs.jl\n implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both \nGraph\n or both \nDiGraph\n).\n\n\n\n\nBase.SparseArrays.blkdiag\n\n\nBase.intersect\n\n\nBase.join\n\n\nBase.reverse\n\n\nBase.reverse!\n\n\nBase.union\n\n\nLightGraphs.cartesian_product\n\n\nLightGraphs.complement\n\n\nLightGraphs.crosspath\n\n\nLightGraphs.difference\n\n\nLightGraphs.egonet\n\n\nLightGraphs.induced_subgraph\n\n\nLightGraphs.symmetric_difference\n\n\nLightGraphs.tensor_product\n\n\n\n\n#\n\n\nBase.SparseArrays.blkdiag\n \n \nMethod\n.\n\n\nblkdiag(g, h)\n\n\n\n\nReturn a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges where the vertices an edges from graph \nh\n are appended to graph \ng\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nBase.intersect\n \n \nMethod\n.\n\n\nintersect(g, h)\n\n\n\n\nReturn a graph with edges that are only in both graph \ng\n and graph \nh\n.\n\n\nImplementation Notes\n\n\nThis function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nBase.join\n \n \nMethod\n.\n\n\njoin(g, h)\n\n\n\n\nReturn a graph that combines graphs \ng\n and \nh\n using \nblkdiag\n and then adds all the edges between the vertices in \ng\n and those in \nh\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nFunction\n.\n\n\nreverse(g)\n\n\n\n\nReturn a directed graph where all edges are reversed from the original directed graph.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nBase.reverse!\n \n \nFunction\n.\n\n\nreverse!(g)\n\n\n\n\nIn-place reverse of a directed graph (modifies the original graph).\n\n\nsource\n\n\n#\n\n\nBase.union\n \n \nMethod\n.\n\n\nunion(g, h)\n\n\n\n\nReturn a graph that combines graphs \ng\n and \nh\n by taking the set union of all vertices and edges.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.cartesian_product\n \n \nMethod\n.\n\n\ncartesian_product(g, h)\n\n\n\n\nReturn the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.complement\n \n \nMethod\n.\n\n\ncomplement(g)\n\n\n\n\nReturn the \ngraph complement\n of a graph\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.crosspath\n \n \nFunction\n.\n\n\ncrosspath(len::Integer, g::Graph)\n\n\n\n\nReturn a graph that duplicates \ng\n \nlen\n times and connects each vertex with its copies in a path.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.difference\n \n \nMethod\n.\n\n\ndifference(g, h)\n\n\n\n\nReturn a graph with edges in graph \ng\n that are not in graph \nh\n.\n\n\nImplementation Notes\n\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.egonet\n \n \nMethod\n.\n\n\negonet(g, v:, d)\n\n\n\n\nReturn the subgraph of \ng\n induced by the neighbors of \nv\n up to distance \nd\n. This is equivalent to \ninduced_subgraph\n(g, neighborhood(g, v, d, dir=dir))[1].\n\n\nOptional Arguments\n\n\n\n\ndir=:out\n: if \ng\n is directed, this argument specifies the edge direction\n\n\n\n\nwith respect to \nv\n (i.e. \n:in\n or \n:out\n).\n\n\nsource\n\n\n#\n\n\nLightGraphs.induced_subgraph\n \n \nMethod\n.\n\n\ninduced_subgraph(g, vlist)\ninduced_subgraph(g, elist)\n\n\n\n\nReturn the subgraph of \ng\n induced by the vertices in  \nvlist\n or edges in \nelist\n along with a vector mapping the new vertices to the old ones (the  vertex \ni\n in the subgraph corresponds to the vertex \nvmap[i]\n in \ng\n.)\n\n\nThe returned graph has \nlength(vlist)\n vertices, with the new vertex \ni\n corresponding to the vertex of the original graph in the \ni\n-th position of \nvlist\n.\n\n\nUsage Examples\n\n\njulia\n g = CompleteGraph(10)\n\njulia\n sg, vmap = subgraph(g, 5:8)\n\njulia\n @assert g[5:8] == sg\n\njulia\n @assert nv(sg) == 4\n\njulia\n @assert ne(sg) == 6\n\njulia\n @assert vm[4] == 8\n\njulia\n sg, vmap = subgraph(g, [2,8,3,4])\n\njulia\n @assert sg == g[[2,8,3,4]]\n\njulia\n elist = [Edge(1,2), Edge(3,4), Edge(4,8)]\n\njulia\n sg, vmap = subgraph(g, elist)\n\njulia\n @assert sg == g[elist]\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.symmetric_difference\n \n \nMethod\n.\n\n\nsymmetric_difference(g, h)\n\n\n\n\nReturn a graph with edges from graph \ng\n that do not exist in graph \nh\n, and vice versa.\n\n\nImplementation Notes\n\n\nNote that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource\n\n\n#\n\n\nLightGraphs.tensor_product\n \n \nMethod\n.\n\n\ntensor_product(g, h)\n\n\n\n\nReturn the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n.\n\n\nImplementation Notes\n\n\nPreserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.\n\n\nsource", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#operators", 
            "text": "LightGraphs.jl  implements the following graph operators. In general, functions with two graph arguments will require them to be of the same type (either both  Graph  or both  DiGraph ).   Base.SparseArrays.blkdiag  Base.intersect  Base.join  Base.reverse  Base.reverse!  Base.union  LightGraphs.cartesian_product  LightGraphs.complement  LightGraphs.crosspath  LightGraphs.difference  LightGraphs.egonet  LightGraphs.induced_subgraph  LightGraphs.symmetric_difference  LightGraphs.tensor_product   #  Base.SparseArrays.blkdiag     Method .  blkdiag(g, h)  Return a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges where the vertices an edges from graph  h  are appended to graph  g .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  Base.intersect     Method .  intersect(g, h)  Return a graph with edges that are only in both graph  g  and graph  h .  Implementation Notes  This function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.  source  #  Base.join     Method .  join(g, h)  Return a graph that combines graphs  g  and  h  using  blkdiag  and then adds all the edges between the vertices in  g  and those in  h .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  Base.reverse     Function .  reverse(g)  Return a directed graph where all edges are reversed from the original directed graph.  Implementation Notes  Preserves the eltype of the input graph.  source  #  Base.reverse!     Function .  reverse!(g)  In-place reverse of a directed graph (modifies the original graph).  source  #  Base.union     Method .  union(g, h)  Return a graph that combines graphs  g  and  h  by taking the set union of all vertices and edges.  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.cartesian_product     Method .  cartesian_product(g, h)  Return the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.complement     Method .  complement(g)  Return the  graph complement  of a graph  Implementation Notes  Preserves the eltype of the input graph.  source  #  LightGraphs.crosspath     Function .  crosspath(len::Integer, g::Graph)  Return a graph that duplicates  g   len  times and connects each vertex with its copies in a path.  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.difference     Method .  difference(g, h)  Return a graph with edges in graph  g  that are not in graph  h .  Implementation Notes  Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.  source  #  LightGraphs.egonet     Method .  egonet(g, v:, d)  Return the subgraph of  g  induced by the neighbors of  v  up to distance  d . This is equivalent to  induced_subgraph (g, neighborhood(g, v, d, dir=dir))[1].  Optional Arguments   dir=:out : if  g  is directed, this argument specifies the edge direction   with respect to  v  (i.e.  :in  or  :out ).  source  #  LightGraphs.induced_subgraph     Method .  induced_subgraph(g, vlist)\ninduced_subgraph(g, elist)  Return the subgraph of  g  induced by the vertices in   vlist  or edges in  elist  along with a vector mapping the new vertices to the old ones (the  vertex  i  in the subgraph corresponds to the vertex  vmap[i]  in  g .)  The returned graph has  length(vlist)  vertices, with the new vertex  i  corresponding to the vertex of the original graph in the  i -th position of  vlist .  Usage Examples  julia  g = CompleteGraph(10)\n\njulia  sg, vmap = subgraph(g, 5:8)\n\njulia  @assert g[5:8] == sg\n\njulia  @assert nv(sg) == 4\n\njulia  @assert ne(sg) == 6\n\njulia  @assert vm[4] == 8\n\njulia  sg, vmap = subgraph(g, [2,8,3,4])\n\njulia  @assert sg == g[[2,8,3,4]]\n\njulia  elist = [Edge(1,2), Edge(3,4), Edge(4,8)]\n\njulia  sg, vmap = subgraph(g, elist)\n\njulia  @assert sg == g[elist]  source  #  LightGraphs.symmetric_difference     Method .  symmetric_difference(g, h)  Return a graph with edges from graph  g  that do not exist in graph  h , and vice versa.  Implementation Notes  Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source  #  LightGraphs.tensor_product     Method .  tensor_product(g, h)  Return the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h .  Implementation Notes  Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.  source", 
            "title": "Operators"
        }, 
        {
            "location": "/pathing/", 
            "text": "Path and Traversal\n\n\nLightGraphs.jl\n provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.\n\n\nEdge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by \n[src,dst]\n vertices. That is, \ndistmx[2,4] = 2.5\n assigns the distance \n2.5\n to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs \ndistmx[4,2]\n has to be set.\n\n\nAny graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,\n\n\n\n\ndistance values for undefined edges will be ignored, and\n\n\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\n\n\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.\n\n\n\n\n\n\nGraph Traversal\n\n\nGraph traversal\n refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:\n\n\n\n\nBreadthFirst\n,\n\n\nDepthFirst\n, and\n\n\nMaximumAdjacency\n.\n\n\n\n\n#\n\n\nLightGraphs.bfs_tree\n \n \nFunction\n.\n\n\nbfs_tree(g, s)\n\n\n\n\nProvide a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and return a directed acyclic graph of vertices in the order they were discovered.\n\n\nImplementation Notes\n\n\nThis function is a high level wrapper around \nbfs_tree!\n; use that function for more performance.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dfs_tree\n \n \nFunction\n.\n\n\ndfs_tree(g, s)\n\n\n\n\nReturn an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph \ng\n starting with source vertex \ns\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_adjacency_visit\n \n \nFunction\n.\n\n\nmaximum_adjacency_visit(g[, distmx][, log][, io])\n\n\n\n\nReturn the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n matrix may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n\n\nRandom walks\n\n\nLightGraphs\n includes uniform random walks and self avoiding walks:\n\n\n#\n\n\nLightGraphs.randomwalk\n \n \nFunction\n.\n\n\nrandomwalk(g, s, niter)\n\n\n\n\nPerform a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nLightGraphs.saw\n \n \nFunction\n.\n\n\nsaw(g, s, niter)\n\n\n\n\nPerform a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Return a vector of vertices visited in order.\n\n\nsource\n\n\n\n\nConnectivity / Bipartiteness\n\n\nGraph connectivity\n functions are defined on both undirected and directed graphs:\n\n\nis_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod\n\n\n\n\n\n\nCycle Detection\n\n\nIn graph theory, a cycle is defined to be a path that starts from some vertex \nv\n and ends up at \nv\n.\n\n\n#\n\n\nLightGraphs.is_cyclic\n \n \nFunction\n.\n\n\nis_cyclic(g)\n\n\n\n\nReturn \ntrue\n if graph \ng\n contains a cycle.\n\n\nImplementation Notes\n\n\nUses DFS.\n\n\nsource\n\n\n\n\nShortest-Path Algorithms\n\n\n\n\nGeneral properties of shortest path algorithms\n\n\n\n\nThe distance from a vertex to itself is always \n0\n.\n\n\nThe distance between two vertices with no connecting edge is always \nInf\n.\n\n\n\n\n#\n\n\nLightGraphs.a_star\n \n \nFunction\n.\n\n\na_star(g, s, t[, distmx][, heuristic])\n\n\n\n\nReturn a vector of edges comprising the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to \nDefaultDistance\n and the heuristic is set to \nn -\n 0\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.dijkstra_shortest_paths\n \n \nFunction\n.\n\n\ndijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());\n\n\n\n\nPerform \nDijkstra's algorithm\n on a graph, computing shortest distances between \nsrcs\n and all other vertices. Return a \nDijkstraState\n that contains various traversal information.\n\n\nOptional Arguments\n\n\n\n\nallpaths=false\n: If true, returns a \nDijkstraState\n that keeps track of all\n\n\n\n\npredecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nLightGraphs.bellman_ford_shortest_paths\n \n \nFunction\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())\n\n\n\n\nCompute shortest paths between a source \ns\n (or list of sources \nss\n) and all other nodes in graph \ng\n using the \nBellman-Ford algorithm\n. Return a \nBellmanFordState\n with relevant traversal information.\n\n\nsource\n\n\n#\n\n\nLightGraphs.floyd_warshall_shortest_paths\n \n \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the \nFloyd-Warshall algorithm\n to compute the shortest paths between all pairs of vertices in graph \ng\n using an optional distance matrix \ndistmx\n. Return a \nFloydWarshallState\n with relevant traversal information.\n\n\nPerformance\n\n\nSpace complexity is on the order of $\\mathcal{O}(|V|^2)$.\n\n\nsource\n\n\n\n\nPath discovery / enumeration\n\n\n#\n\n\nLightGraphs.gdistances\n \n \nFunction\n.\n\n\ngdistances(g, source)\n\n\n\n\nReturn a vector filled with the geodesic distances of vertices in  \ng\n from \nsource\n. If \nsource\n is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.gdistances!\n \n \nFunction\n.\n\n\ngdistances!(g, source, dists)\n\n\n\n\nFill \ndists\n with the geodesic distances of vertices in \ng\n from \nsource\n. \ndists\n should be a vector of length \nnv(g)\n. Return \ndists\n. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nLightGraphs.enumerate_paths\n \n \nFunction\n.\n\n\nenumerate_paths(state[, vs])\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nImplementation Notes\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\n\n\nPath States\n\n\nThe \nfloyd_warshall_shortest_paths\n, \nbellman_ford_shortest_paths\n, \ndijkstra_shortest_paths\n, and \ndijkstra_predecessor_and_distance\n functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:\n\n\n.dists\n Holds a vector of distances computed, indexed by source vertex.\n\n\n.parents\n Holds a vector of parents of each source vertex. The parent of a source vertex is always \n0\n.\n\n\nIn addition, the \ndijkstra_predecessor_and_distance\n function stores the following information:\n\n\n.predecessors\n Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\n\n.pathcounts\n Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the \n.predecessors\n output above.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#path-and-traversal", 
            "text": "LightGraphs.jl  provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.  Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by  [src,dst]  vertices. That is,  distmx[2,4] = 2.5  assigns the distance  2.5  to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs  distmx[4,2]  has to be set.  Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,   distance values for undefined edges will be ignored, and  any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.  any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/pathing/#graph-traversal", 
            "text": "Graph traversal  refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:   BreadthFirst ,  DepthFirst , and  MaximumAdjacency .   #  LightGraphs.bfs_tree     Function .  bfs_tree(g, s)  Provide a breadth-first traversal of the graph  g  starting with source vertex  s , and return a directed acyclic graph of vertices in the order they were discovered.  Implementation Notes  This function is a high level wrapper around  bfs_tree! ; use that function for more performance.  source  #  LightGraphs.dfs_tree     Function .  dfs_tree(g, s)  Return an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph  g  starting with source vertex  s .  source  #  LightGraphs.maximum_adjacency_visit     Function .  maximum_adjacency_visit(g[, distmx][, log][, io])  Return the vertices in  g  traversed by maximum adjacency search. An optional  distmx  matrix may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source", 
            "title": "Graph Traversal"
        }, 
        {
            "location": "/pathing/#random-walks", 
            "text": "LightGraphs  includes uniform random walks and self avoiding walks:  #  LightGraphs.randomwalk     Function .  randomwalk(g, s, niter)  Perform a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source  #  LightGraphs.saw     Function .  saw(g, s, niter)  Perform a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Return a vector of vertices visited in order.  source", 
            "title": "Random walks"
        }, 
        {
            "location": "/pathing/#connectivity-bipartiteness", 
            "text": "Graph connectivity  functions are defined on both undirected and directed graphs:  is_connected\nis_strongly_connected\nis_weakly_connected\nconnected_components\nstrongly_connected_components\nweakly_connected_components\nhas_self_loop\nattracting_components\nis_bipartite\ncondensation\nperiod", 
            "title": "Connectivity / Bipartiteness"
        }, 
        {
            "location": "/pathing/#cycle-detection", 
            "text": "In graph theory, a cycle is defined to be a path that starts from some vertex  v  and ends up at  v .  #  LightGraphs.is_cyclic     Function .  is_cyclic(g)  Return  true  if graph  g  contains a cycle.  Implementation Notes  Uses DFS.  source", 
            "title": "Cycle Detection"
        }, 
        {
            "location": "/pathing/#shortest-path-algorithms", 
            "text": "", 
            "title": "Shortest-Path Algorithms"
        }, 
        {
            "location": "/pathing/#general-properties-of-shortest-path-algorithms", 
            "text": "The distance from a vertex to itself is always  0 .  The distance between two vertices with no connecting edge is always  Inf .   #  LightGraphs.a_star     Function .  a_star(g, s, t[, distmx][, heuristic])  Return a vector of edges comprising the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to  DefaultDistance  and the heuristic is set to  n -  0 .  source  #  LightGraphs.dijkstra_shortest_paths     Function .  dijkstra_shortest_paths(g, srcs, distmx=DefaultDistance());  Perform  Dijkstra's algorithm  on a graph, computing shortest distances between  srcs  and all other vertices. Return a  DijkstraState  that contains various traversal information.  Optional Arguments   allpaths=false : If true, returns a  DijkstraState  that keeps track of all   predecessors of a given vertex.  source  #  LightGraphs.bellman_ford_shortest_paths     Function .  bellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, ss, distmx=DefaultDistance())  Compute shortest paths between a source  s  (or list of sources  ss ) and all other nodes in graph  g  using the  Bellman-Ford algorithm . Return a  BellmanFordState  with relevant traversal information.  source  #  LightGraphs.floyd_warshall_shortest_paths     Function .  floyd_warshall_shortest_paths(g, distmx=DefaultDistance()) Use the  Floyd-Warshall algorithm  to compute the shortest paths between all pairs of vertices in graph  g  using an optional distance matrix  distmx . Return a  FloydWarshallState  with relevant traversal information.  Performance  Space complexity is on the order of $\\mathcal{O}(|V|^2)$.  source", 
            "title": "General properties of shortest path algorithms"
        }, 
        {
            "location": "/pathing/#path-discovery-enumeration", 
            "text": "#  LightGraphs.gdistances     Function .  gdistances(g, source)  Return a vector filled with the geodesic distances of vertices in   g  from  source . If  source  is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.gdistances!     Function .  gdistances!(g, source, dists)  Fill  dists  with the geodesic distances of vertices in  g  from  source .  dists  should be a vector of length  nv(g) . Return  dists . For vertices in disconnected components the default distance is -1.  source  #  LightGraphs.enumerate_paths     Function .  enumerate_paths(state[, vs])  Given a path state  state  of type  AbstractPathState , return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  Implementation Notes  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .", 
            "title": "Path discovery / enumeration"
        }, 
        {
            "location": "/pathing/#path-states", 
            "text": "The  floyd_warshall_shortest_paths ,  bellman_ford_shortest_paths ,  dijkstra_shortest_paths , and  dijkstra_predecessor_and_distance  functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:  .dists  Holds a vector of distances computed, indexed by source vertex.  .parents  Holds a vector of parents of each source vertex. The parent of a source vertex is always  0 .  In addition, the  dijkstra_predecessor_and_distance  function stores the following information:  .predecessors  Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.  .pathcounts  Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the  .predecessors  output above.", 
            "title": "Path States"
        }, 
        {
            "location": "/distance/", 
            "text": "Distance\n\n\nLightGraphs.jl\n includes the following distance measurements:\n\n\n#\n\n\nLightGraphs.BoundedMinkowskiCost\n \n \nMethod\n.\n\n\nBoundedMinkowskiCost(\u03bc\u2081, \u03bc\u2082)\n\n\n\n\nReturn value similar to \nMinkowskiCost\n, but ensure costs smaller than 2\u03c4.\n\n\nOptional Arguments\n\n\np=1\n: the p value for p-norm calculation. \n\u03c4=1\n: value specifying half of the upper limit of the Minkowski cost.\n\n\nsource\n\n\n#\n\n\nLightGraphs.MinkowskiCost\n \n \nMethod\n.\n\n\nMinkowskiCost(\u03bc\u2081, \u03bc\u2082; p::Real=1)\n\n\n\n\nFor labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.\n\n\nOptional Arguments\n\n\np=1\n: the p value for p-norm calculation.\n\n\nsource\n\n\n#\n\n\nLightGraphs.center\n \n \nMethod\n.\n\n\ncenter(g, distmx=DefaultDistance())\ncenter(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\n\nsource\n\n\n#\n\n\nLightGraphs.diameter\n \n \nMethod\n.\n\n\ndiameter(g, distmx=DefaultDistance())\ndiameter(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.eccentricity\n \n \nMethod\n.\n\n\neccentricity(g[, v][, distmx])\n\n\n\n\nReturn the eccentricity[ies] of a vertex / vertex list \nv\n or the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to \n1\n.\n\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\n\nThe output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.\n\n\nPerformance\n\n\nBecause this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.\n\n\nImplementation Notes\n\n\nThe eccentricity vector returned by \neccentricity()\n may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.\n\n\nsource\n\n\n#\n\n\nLightGraphs.edit_distance\n \n \nMethod\n.\n\n\nedit_distance(G\u2081::AbstractGraph, G\u2082::AbstractGraph)\n\n\n\n\nCompute the edit distance between graphs \nG\u2081\n and \nG\u2082\n. Return the minimum edit cost and edit path to transform graph \nG\u2081\n into graph `G\u2082\n. An edit path consists of a sequence of pairs of vertices\n(u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|]`` representing vertex operations:\n\n\n\n\n$(0,v)$: insertion of vertex $v \u2208 G\u2082$\n\n\n$(u,0)$: deletion of vertex $u \u2208 G\u2081$\n\n\n$(u\n0,v\n0)$: substitution of vertex $u \u2208 G\u2081$ by vertex $v \u2208 G\u2082$\n\n\n\n\nOptional Arguments\n\n\n\n\ninsert_cost::Function=v-\n1.0\n\n\ndelete_cost::Function=u-\n1.0\n\n\nsubst_cost::Function=(u,v)-\n0.5\n\n\n\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:\n\n\nedit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))\n\n\n\n\n\n\nheuristic::Function=DefaultEditHeuristic\n: a custom heuristic provided to the A*\n\n\n\n\nsearch in case the default heuristic is not satisfactory.\n\n\nPerformance\n\n\n\n\nGiven two graphs $|G\u2081| \n |G\u2082|$, \nedit_distance(G\u2081, G\u2082)\n is faster to\n\n\n\n\ncompute than \nedit_distance(G\u2082, G\u2081)\n. Consider swapping the arguments if involved costs are equivalent.\n\n\n\n\nThe use of simple Minkowski costs can improve performance considerably.\n\n\nExploit vertex attributes when designing operation costs.\n\n\n\n\nReferences\n\n\n\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\n\n\n\nAuthor\n\n\n\n\nJ\u00falio Hoffimann Mendes (juliohm@stanford.edu)\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.periphery\n \n \nMethod\n.\n\n\nperiphery(g, distmx=DefaultDistance())\nperiphery(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\n\nsource\n\n\n#\n\n\nLightGraphs.radius\n \n \nMethod\n.\n\n\nradius(g, distmx=DefaultDistance())\nradius(eccentricities)\n\n\n\n\nGiven a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.\n\n\nsource", 
            "title": "Distance"
        }, 
        {
            "location": "/distance/#distance", 
            "text": "LightGraphs.jl  includes the following distance measurements:  #  LightGraphs.BoundedMinkowskiCost     Method .  BoundedMinkowskiCost(\u03bc\u2081, \u03bc\u2082)  Return value similar to  MinkowskiCost , but ensure costs smaller than 2\u03c4.  Optional Arguments  p=1 : the p value for p-norm calculation.  \u03c4=1 : value specifying half of the upper limit of the Minkowski cost.  source  #  LightGraphs.MinkowskiCost     Method .  MinkowskiCost(\u03bc\u2081, \u03bc\u2082; p::Real=1)  For labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.  Optional Arguments  p=1 : the p value for p-norm calculation.  source  #  LightGraphs.center     Method .  center(g, distmx=DefaultDistance())\ncenter(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).  source  #  LightGraphs.diameter     Method .  diameter(g, distmx=DefaultDistance())\ndiameter(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.  source  #  LightGraphs.eccentricity     Method .  eccentricity(g[, v][, distmx])  Return the eccentricity[ies] of a vertex / vertex list  v  or the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to  1 .  The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.  The output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.  Performance  Because this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.  Implementation Notes  The eccentricity vector returned by  eccentricity()  may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.  source  #  LightGraphs.edit_distance     Method .  edit_distance(G\u2081::AbstractGraph, G\u2082::AbstractGraph)  Compute the edit distance between graphs  G\u2081  and  G\u2082 . Return the minimum edit cost and edit path to transform graph  G\u2081  into graph `G\u2082 . An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|]`` representing vertex operations:   $(0,v)$: insertion of vertex $v \u2208 G\u2082$  $(u,0)$: deletion of vertex $u \u2208 G\u2081$  $(u 0,v 0)$: substitution of vertex $u \u2208 G\u2081$ by vertex $v \u2208 G\u2082$   Optional Arguments   insert_cost::Function=v- 1.0  delete_cost::Function=u- 1.0  subst_cost::Function=(u,v)- 0.5   By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:  edit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))   heuristic::Function=DefaultEditHeuristic : a custom heuristic provided to the A*   search in case the default heuristic is not satisfactory.  Performance   Given two graphs $|G\u2081|   |G\u2082|$,  edit_distance(G\u2081, G\u2082)  is faster to   compute than  edit_distance(G\u2082, G\u2081) . Consider swapping the arguments if involved costs are equivalent.   The use of simple Minkowski costs can improve performance considerably.  Exploit vertex attributes when designing operation costs.   References   RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)   Author   J\u00falio Hoffimann Mendes (juliohm@stanford.edu)   source  #  LightGraphs.periphery     Method .  periphery(g, distmx=DefaultDistance())\nperiphery(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).  source  #  LightGraphs.radius     Method .  radius(g, distmx=DefaultDistance())\nradius(eccentricities)  Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.  source", 
            "title": "Distance"
        }, 
        {
            "location": "/centrality/", 
            "text": "Centrality Measures\n\n\nCentrality measures\n describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in \nLightGraphs.jl\n include the following:\n\n\n\n\nLightGraphs.betweenness_centrality\n\n\nLightGraphs.closeness_centrality\n\n\nLightGraphs.degree_centrality\n\n\nLightGraphs.katz_centrality\n\n\nLightGraphs.pagerank\n\n\n\n\n#\n\n\nLightGraphs.betweenness_centrality\n \n \nFunction\n.\n\n\nbetweenness_centrality(g[, vs])\nbetweenness_centrality(g, k)\n\n\n\n\nCalculate the \nbetweenness centrality\n of a graph \ng\n across all vertices, a specified subset of vertices \nvs\n, or a random subset of \nk\n vertices. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nOptional Arguments\n\n\n\n\nnormalize=true\n: If true, normalize the betweenness values by the\n\n\n\n\ntotal number of possible distinct paths between all pairsin the graphs. For an undirected graph, this number is $\\frac{(|V|-1)(|V|-2)}{2}$ and for a directed graph, ${(|V|-1)(|V|-2)}$.\n\n\n\n\nendpoints=false\n: If true, include endpoints in the shortest path count.\n\n\n\n\nBetweenness centrality is defined as: $bc(v) = \\frac{1}{\\mathcal{N}} sum_{s \\neq t \\neq v} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$.\n\n\nReferences\n\n\n\n\nBrandes 2001 \n Brandes 2008\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.closeness_centrality\n \n \nMethod\n.\n\n\ncloseness_centrality(g)\n\n\n\n\nCalculate the \ncloseness centrality\n of the graph \ng\n. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nOptional Arguments\n\n\n\n\nnormalize=true\n: If true, normalize the centrality value of each\n\n\n\n\nnode \nn\n by $\\frac{|\u03b4_n|}{|V|-1}$, where $\u03b4_n$ is the set of vertices reachable from node \nn\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.degree_centrality\n \n \nMethod\n.\n\n\ndegree_centrality(g)\nindegree_centrality(g)\noutdegree_centrality(g)\n\n\n\n\nCalculate the \ndegree centrality\n of graph \ng\n. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nOptional Arguments\n\n\n\n\nnormalize=true\n: If true, normalize each centrality measure by $rac{1}{|V|-1}$.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.katz_centrality\n \n \nFunction\n.\n\n\nkatz_centrality(g, \u03b1=0.3)\n\n\n\n\nCalculate the \nKatz centrality\n of the graph \ng\n optionally parameterized by \n\u03b1\n. Return a vector representing the centrality calculated for each node in \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.pagerank\n \n \nFunction\n.\n\n\npagerank(g, \u03b1=0.85, n=100, \u03f5=1.0e-6)\n\n\n\n\nCalculate the \nPageRank\n of the directed graph \ng\n parameterized by damping factor \n\u03b1\n, number of iterations \nn\n, and convergence threshold \n\u03f5\n. Return a vector representing the centrality calculated for each node in \ng\n, or an error if convergence is not reached within \nn\n iterations.\n\n\nsource", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/centrality/#centrality-measures", 
            "text": "Centrality measures  describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in  LightGraphs.jl  include the following:   LightGraphs.betweenness_centrality  LightGraphs.closeness_centrality  LightGraphs.degree_centrality  LightGraphs.katz_centrality  LightGraphs.pagerank   #  LightGraphs.betweenness_centrality     Function .  betweenness_centrality(g[, vs])\nbetweenness_centrality(g, k)  Calculate the  betweenness centrality  of a graph  g  across all vertices, a specified subset of vertices  vs , or a random subset of  k  vertices. Return a vector representing the centrality calculated for each node in  g .  Optional Arguments   normalize=true : If true, normalize the betweenness values by the   total number of possible distinct paths between all pairsin the graphs. For an undirected graph, this number is $\\frac{(|V|-1)(|V|-2)}{2}$ and for a directed graph, ${(|V|-1)(|V|-2)}$.   endpoints=false : If true, include endpoints in the shortest path count.   Betweenness centrality is defined as: $bc(v) = \\frac{1}{\\mathcal{N}} sum_{s \\neq t \\neq v} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$.  References   Brandes 2001   Brandes 2008   source  #  LightGraphs.closeness_centrality     Method .  closeness_centrality(g)  Calculate the  closeness centrality  of the graph  g . Return a vector representing the centrality calculated for each node in  g .  Optional Arguments   normalize=true : If true, normalize the centrality value of each   node  n  by $\\frac{|\u03b4_n|}{|V|-1}$, where $\u03b4_n$ is the set of vertices reachable from node  n .  source  #  LightGraphs.degree_centrality     Method .  degree_centrality(g)\nindegree_centrality(g)\noutdegree_centrality(g)  Calculate the  degree centrality  of graph  g . Return a vector representing the centrality calculated for each node in  g .  Optional Arguments   normalize=true : If true, normalize each centrality measure by $rac{1}{|V|-1}$.   source  #  LightGraphs.katz_centrality     Function .  katz_centrality(g, \u03b1=0.3)  Calculate the  Katz centrality  of the graph  g  optionally parameterized by  \u03b1 . Return a vector representing the centrality calculated for each node in  g .  source  #  LightGraphs.pagerank     Function .  pagerank(g, \u03b1=0.85, n=100, \u03f5=1.0e-6)  Calculate the  PageRank  of the directed graph  g  parameterized by damping factor  \u03b1 , number of iterations  n , and convergence threshold  \u03f5 . Return a vector representing the centrality calculated for each node in  g , or an error if convergence is not reached within  n  iterations.  source", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/linalg/", 
            "text": "Linear Algebra\n\n\nLightGraphs.jl\n provides the following matrix operations on both directed and undirected graphs:\n\n\n#\n\n\nLightGraphs.adjacency_matrix\n \n \nFunction\n.\n\n\nadjacency_matrix(g, dir=:out, T=Int)\n\n\n\n\nReturn a sparse adjacency matrix for a graph, indexed by \n[u, v]\n vertices. Non-zero values indicate an edge between \nu\n and \nv\n. Users may specify a direction (\n:in\n, \n:out\n, or \n:both\n are currently supported; \n:out\n is default for both directed and undirected graphs) and a data type for the matrix (defaults to \nInt\n).\n\n\nImplementation Notes\n\n\nThis function is optimized for speed and directly manipulates CSC sparse matrix fields.\n\n\nsource\n\n\n#\n\n\nLightGraphs.adjacency_spectrum\n \n \nFunction\n.\n\n\nReturn the eigenvalues of the adjacency matrix for a graph \ng\n, indexed by vertex. Default values for \ndir\n and \nT\n are the same as those in \nadjacency_matrix\n.\n\n\nPerformance\n\n\nConverts the matrix to dense with $nv^2$ memory usage.\n\n\nImplementation Notes\n\n\nUse \neigs(adjacency_matrix(g);  kwargs...)\n to compute some of the eigenvalues/eigenvectors.\n\n\nsource\n\n\n#\n\n\nLightGraphs.incidence_matrix\n \n \nFunction\n.\n\n\nincidence_matrix(g, T=Int)\n\n\n\n\nReturn a sparse node-arc incidence matrix for a graph, indexed by \n[v, i]\n, where \ni\n is in \n1:ne(g)\n, indexing an edge \ne\n. For directed graphs, a value of \n-1\n indicates that \nsrc(e) == v\n, while a value of \n1\n indicates that \ndst(e) == v\n. Otherwise, the value is \n0\n. For undirected graphs, both entries are \n1\n by default (this behavior can be overridden by the \noriented\n optional argument).\n\n\nOptional Arguments\n\n\n\n\noriented=false\n: If true, for an undirected graph \ng\n, the matrix will\n\n\n\n\ncontain arbitrary non-zero values representing connectivity between \nv\n and \ni\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.laplacian_matrix\n \n \nFunction\n.\n\n\nlaplacian_matrix(g, dir=:unspec, T=Int)\n\n\n\n\nReturn a sparse \nLaplacian matrix\n for a graph \ng\n, indexed by \n[u, v]\n vertices. For undirected graphs, \ndir\n defaults to \n:out\n; for directed graphs, \ndir\n defaults to \n:both\n. \nT\n defaults to \nInt\n for both graph types.\n\n\nsource\n\n\n#\n\n\nLightGraphs.laplacian_spectrum\n \n \nFunction\n.\n\n\nlaplacian_spectrum(g, dir=:unspec, T=Int)\n\n\n\n\nReturn the eigenvalues of the Laplacian matrix for a graph \ng\n, indexed by vertex. Default values for \ndir\n and \nT\n are the same as those in \nlaplacian_matrix\n.\n\n\nPerformance\n\n\nConverts the matrix to dense with $nv^2$ memory usage.\n\n\nImplementation Notes\n\n\nUse \neigs(laplacian_matrix(g);  kwargs...)\n to compute some of the eigenvalues/eigenvectors.\n\n\nsource\n\n\n#\n\n\nLightGraphs.spectral_distance\n \n \nFunction\n.\n\n\nspectral_distance(G\u2081, G\u2082 [, k])\n\n\n\n\nCompute the spectral distance between undirected n-vertex graphs \nG\u2081\n and \nG\u2082\n using the top \nk\n greatest eigenvalues. If \nk\n is ommitted, uses full spectrum.\n\n\nReferences\n\n\n\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\n\n\nsource", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/linalg/#linear-algebra", 
            "text": "LightGraphs.jl  provides the following matrix operations on both directed and undirected graphs:  #  LightGraphs.adjacency_matrix     Function .  adjacency_matrix(g, dir=:out, T=Int)  Return a sparse adjacency matrix for a graph, indexed by  [u, v]  vertices. Non-zero values indicate an edge between  u  and  v . Users may specify a direction ( :in ,  :out , or  :both  are currently supported;  :out  is default for both directed and undirected graphs) and a data type for the matrix (defaults to  Int ).  Implementation Notes  This function is optimized for speed and directly manipulates CSC sparse matrix fields.  source  #  LightGraphs.adjacency_spectrum     Function .  Return the eigenvalues of the adjacency matrix for a graph  g , indexed by vertex. Default values for  dir  and  T  are the same as those in  adjacency_matrix .  Performance  Converts the matrix to dense with $nv^2$ memory usage.  Implementation Notes  Use  eigs(adjacency_matrix(g);  kwargs...)  to compute some of the eigenvalues/eigenvectors.  source  #  LightGraphs.incidence_matrix     Function .  incidence_matrix(g, T=Int)  Return a sparse node-arc incidence matrix for a graph, indexed by  [v, i] , where  i  is in  1:ne(g) , indexing an edge  e . For directed graphs, a value of  -1  indicates that  src(e) == v , while a value of  1  indicates that  dst(e) == v . Otherwise, the value is  0 . For undirected graphs, both entries are  1  by default (this behavior can be overridden by the  oriented  optional argument).  Optional Arguments   oriented=false : If true, for an undirected graph  g , the matrix will   contain arbitrary non-zero values representing connectivity between  v  and  i .  source  #  LightGraphs.laplacian_matrix     Function .  laplacian_matrix(g, dir=:unspec, T=Int)  Return a sparse  Laplacian matrix  for a graph  g , indexed by  [u, v]  vertices. For undirected graphs,  dir  defaults to  :out ; for directed graphs,  dir  defaults to  :both .  T  defaults to  Int  for both graph types.  source  #  LightGraphs.laplacian_spectrum     Function .  laplacian_spectrum(g, dir=:unspec, T=Int)  Return the eigenvalues of the Laplacian matrix for a graph  g , indexed by vertex. Default values for  dir  and  T  are the same as those in  laplacian_matrix .  Performance  Converts the matrix to dense with $nv^2$ memory usage.  Implementation Notes  Use  eigs(laplacian_matrix(g);  kwargs...)  to compute some of the eigenvalues/eigenvectors.  source  #  LightGraphs.spectral_distance     Function .  spectral_distance(G\u2081, G\u2082 [, k])  Compute the spectral distance between undirected n-vertex graphs  G\u2081  and  G\u2082  using the top  k  greatest eigenvalues. If  k  is ommitted, uses full spectrum.  References   JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations   source", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/matching/", 
            "text": "Matching\n\n\nMaximum weight matching  is supperted in the companion package \nLightGraphsExtras.jl", 
            "title": "Matching"
        }, 
        {
            "location": "/matching/#matching", 
            "text": "Maximum weight matching  is supperted in the companion package  LightGraphsExtras.jl", 
            "title": "Matching"
        }, 
        {
            "location": "/community/", 
            "text": "Community Structures\n\n\nLightGraphs.jl\n contains many algorithm to detect and analyze community structures in graphs.\n\n\n#\n\n\nLightGraphs.global_clustering_coefficient\n \n \nMethod\n.\n\n\nglobal_clustering_coefficient(g)\n\n\n\n\nReturn the \nglobal clustering coefficient\n of graph \ng\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering\n \n \nMethod\n.\n\n\nlocal_clustering(g, v)\nlocal_clustering(g, vs)\n\n\n\n\nReturn a tuple \n(a, b)\n, where \na\n is the number of triangles in the neighborhood of \nv\n and \nb\n is the maximum number of possible triangles. If a list of vertices \nvs\n is specified, return two vectors representing the number of triangles and the maximum number of possible triangles, respectively, for each node in the list.\n\n\nThis function is related to the local clustering coefficient \nr\n by $r=\frac{a}{b}$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.local_clustering_coefficient\n \n \nMethod\n.\n\n\nlocal_clustering_coefficient(g, v)\nlocal_clustering_coefficient(g, vs)\n\n\n\n\nReturn the \nlocal clustering coefficient\n for node \nv\n in graph \ng\n. If a list of vertices \nvs\n is specified, return a vector of coefficients for each node in the list.\n\n\nsource\n\n\n#\n\n\nLightGraphs.triangles\n \n \nMethod\n.\n\n\ntriangles(g[, v])\ntriangles(g, vs)\n\n\n\n\nReturn the number of triangles in the neighborhood of node \nv\n in graph \ng\n. If a list of vertices \nvs\n is specified, return a vector of number of triangles for each node in the list. If no vertices are specified, return the number of triangles for each node in the graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.core_periphery_deg\n \n \nFunction\n.\n\n\ncore_periphery_deg(g)\n\n\n\n\nCompute the degree-based core-periphery for graph \ng\n. Return the vertex assignments (\n1\n for core and \n2\n for periphery) for each node in \ng\n.\n\n\nReferences:     \nLip\n)\n\n\nsource\n\n\n#\n\n\nLightGraphs.label_propagation\n \n \nFunction\n.\n\n\nlabel_propagation(g, maxiter=1000)\n\n\n\n\nCommunity detection using the label propagation algorithm. Return two vectors: the first is the label number assigned to each node, and the second is the convergence history for each node. Will return after \nmaxiter\n iterations if convergence has not completed.\n\n\nReferences\n\n\n\n\nRaghavan et al.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.modularity\n \n \nFunction\n.\n\n\nmodularity(g, c)\n\n\n\n\nReturn a value representing Newman's modularity \nQ\n for the undirected graph \ng\n given the partitioning vector \nc\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximal_cliques\n \n \nFunction\n.\n\n\nmaximal_cliques(g)\n\n\n\n\nReturn a vector of vectors representing the node indices in each of the maximal cliques found in the undirected graph \ng\n.\n\n\njulia\n using LightGraphs\njulia\n g = Graph(3)\njulia\n add_edge!(g, 1, 2)\njulia\n add_edge!(g, 2, 3)\njulia\n maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\nsource", 
            "title": "Community Structures"
        }, 
        {
            "location": "/community/#community-structures", 
            "text": "LightGraphs.jl  contains many algorithm to detect and analyze community structures in graphs.  #  LightGraphs.global_clustering_coefficient     Method .  global_clustering_coefficient(g)  Return the  global clustering coefficient  of graph  g .  source  #  LightGraphs.local_clustering     Method .  local_clustering(g, v)\nlocal_clustering(g, vs)  Return a tuple  (a, b) , where  a  is the number of triangles in the neighborhood of  v  and  b  is the maximum number of possible triangles. If a list of vertices  vs  is specified, return two vectors representing the number of triangles and the maximum number of possible triangles, respectively, for each node in the list.  This function is related to the local clustering coefficient  r  by $r=\frac{a}{b}$.  source  #  LightGraphs.local_clustering_coefficient     Method .  local_clustering_coefficient(g, v)\nlocal_clustering_coefficient(g, vs)  Return the  local clustering coefficient  for node  v  in graph  g . If a list of vertices  vs  is specified, return a vector of coefficients for each node in the list.  source  #  LightGraphs.triangles     Method .  triangles(g[, v])\ntriangles(g, vs)  Return the number of triangles in the neighborhood of node  v  in graph  g . If a list of vertices  vs  is specified, return a vector of number of triangles for each node in the list. If no vertices are specified, return the number of triangles for each node in the graph.  source  #  LightGraphs.core_periphery_deg     Function .  core_periphery_deg(g)  Compute the degree-based core-periphery for graph  g . Return the vertex assignments ( 1  for core and  2  for periphery) for each node in  g .  References:      Lip )  source  #  LightGraphs.label_propagation     Function .  label_propagation(g, maxiter=1000)  Community detection using the label propagation algorithm. Return two vectors: the first is the label number assigned to each node, and the second is the convergence history for each node. Will return after  maxiter  iterations if convergence has not completed.  References   Raghavan et al.   source  #  LightGraphs.modularity     Function .  modularity(g, c)  Return a value representing Newman's modularity  Q  for the undirected graph  g  given the partitioning vector  c .  source  #  LightGraphs.maximal_cliques     Function .  maximal_cliques(g)  Return a vector of vectors representing the node indices in each of the maximal cliques found in the undirected graph  g .  julia  using LightGraphs\njulia  g = Graph(3)\njulia  add_edge!(g, 1, 2)\njulia  add_edge!(g, 2, 3)\njulia  maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]  source", 
            "title": "Community Structures"
        }, 
        {
            "location": "/flowcut/", 
            "text": "Flow and Cut\n\n\nLightGraphs.jl\n provides different algorithms for \nmaximum flow\n and minimum cut computations.\n\n\n#\n\n\nLightGraphs.BoykovKolmogorovAlgorithm\n \n \nType\n.\n\n\nBoykovKolmogorovAlgorithm \n: AbstractFlowAlgorithm\n\n\n\n\nForces the maximum_flow function to use the Boykov-Kolmogorov algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.DinicAlgorithm\n \n \nType\n.\n\n\nDinicAlgorithm \n: AbstractFlowAlgorithm\n\n\n\n\nForces the maximum_flow function to use Dinic's algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.EdmondsKarpAlgorithm\n \n \nType\n.\n\n\nEdmondsKarpAlgorithm \n: AbstractFlowAlgorithm\n\n\n\n\nForces the maximum_flow function to use the Edmonds\u2013Karp algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PushRelabelAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Push-Relabel algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.maximum_flow\n \n \nFunction\n.\n\n\nmaximum_flow(flow_graph, source, target[, capacity_matrix][, algorithm][, restriction])\n\n\n\n\nGeneric maximum_flow function for \nflow_graph\n from \nsource\n to \ntarget\n with capacities in \ncapacity_matrix\n. Uses flow algorithm \nalgorithm\n and cutoff restriction \nrestriction\n.\n\n\n\n\nIf \ncapacity_matrix\n is not specified, \nDefaultCapacity(flow_graph)\n will be used.\n\n\nIf \nalgorithm\n is not specified, it will default to \nPushRelabelAlgorithm\n.\n\n\nIf \nrestriction\n is not specified, it will default to \n0\n.\n\n\n\n\nReturn a tuple of (maximum flow, flow matrix). For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nUsage Example:\n\n\njulia\n flow_graph = DiGraph(8) # Create a flow-graph\njulia\n flow_edges = [\n(1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n(2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n(5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\n\njulia\n capacity_matrix = zeros(Int, 8, 8)  # Create a capacity matrix\n\njulia\n for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u,v] = f\nend\n\njulia\n f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow without the capacity_matrix\n\njulia\n f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow with the capacity_matrix\n\njulia\n f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm()) # Run Edmonds-Karp algorithm\n\njulia\n f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=DinicAlgorithm()) # Run Dinic's algorithm\n\njulia\n f, F, labels = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=BoykovKolmogorovAlgorithm()) # Run Boykov-Kolmogorov algorithm\n\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.ExtendedMultirouteFlowAlgorithm\n \n \nType\n.\n\n\nExtendedMultirouteFlowAlgorithm\n\n\n\n\nUsed to specify the Extended Multiroute Flow algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.KishimotoAlgorithm\n \n \nType\n.\n\n\nKishimotoAlgorithm\n\n\n\n\nUsed to specify the Kishimoto algorithm.\n\n\nsource\n\n\n#\n\n\nLightGraphs.multiroute_flow\n \n \nMethod\n.\n\n\nmultiroute_flow(flow_graph, source, target[, DefaultCapacity][, flow_algorithm][, mrf_algorithm][, routes])\n\n\n\n\nThe generic multiroute_flow function.\n\n\nThe output will vary depending on the input:\n\n\n\n\nWhen the number of \nroute\ns is \n0\n, return the set of breaking points of\n\n\n\n\nthe multiroute flow.\n\n\n\n\nWhen the number of \nroute\ns is \n1\n, return a flow with a set of 1-disjoint paths\n\n\n\n\n(this is the classical max-flow implementation).\n\n\n\n\nWhen the input is limited to a set of breaking points and a route value \nk\n,\n\n\n\n\nreturn only the k-route flow.\n\n\n\n\nOtherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the\n\n\n\n\nmax-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nWhen the input is a network, it requires the following arguments:\n\n\n\n\nflow_graph\n: the input graph\n\n\nsource\n: the source vertex\n\n\ntarget\n: the target vertex\n\n\ncapacity_matrix\n: matrix of edge flow capacities\n\n\nflow_algorithm\n: keyword argument for flow algorithm\n\n\nmrf_algorithm\n: keyword argument for multiroute flow algorithm\n\n\nroutes\n: keyword argument for the number of routes\n\n\n\n\nWhen the input is only the set of (breaking) points and the number of route, it requires the following arguments:\n\n\n\n\nbreakingpoints\n: vector of breaking points\n\n\nroutes\n: number of routes\n\n\n\n\nWhen the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:\n\n\n\n\nbreakingpoints\n: vector of breaking points\n\n\nroutes\n: number of routes\n\n\nflow_graph\n: the input graph\n\n\nsource\n: the source vertex\n\n\ntarget\n: the target vertex\n\n\ncapacity_matrix\n: matrix of edge flow capacities\n\n\nflow_algorithm\n: keyword argument for flow algorithm\n\n\n\n\nThe function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of \n1\n is assumed for each link if no capacity matrix is provided.\n\n\nThe \nmrf_algorithm\n keyword is inforced to Extended Multiroute Flow in the following cases:\n\n\n\n\nThe number of routes is non-integer\n\n\nThe number of routes is 0 or non-specified\n\n\n\n\nUsage Example :\n\n\n(please consult the  \nmax_flow\n section for options about flow_algorithm and capacity_matrix)\n\n\njulia\n flow_graph = DiGraph(8) # Create a flow graph\n\njulia\n flow_edges = [\n(1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n(2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n(5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\n\njulia\n capacity_matrix = zeros(Int, 8, 8) # Create a capacity matrix\n\njulia\n for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\njulia\n f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2) # Run default multiroute_flow with an integer number of routes = 2\n\njulia\n f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5) # Run default multiroute_flow with a noninteger number of routes = 1.5\n\njulia\n points = multiroute_flow(flow_graph, 1, 8, capacity_matrix) # Run default multiroute_flow for all the breaking points values\n\njulia\n f, F = multiroute_flow(points, 1.5) # Then run multiroute flow algorithm for any positive number of routes\n\njulia\n f = multiroute_flow(points, 1.5, valueonly = true)\n\njulia\n f, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix, algorithm = BoykovKolmogorovAlgorithm(), routes = 2) # Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\n\n\n\n\n\nsource", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/flowcut/#flow-and-cut", 
            "text": "LightGraphs.jl  provides different algorithms for  maximum flow  and minimum cut computations.  #  LightGraphs.BoykovKolmogorovAlgorithm     Type .  BoykovKolmogorovAlgorithm  : AbstractFlowAlgorithm  Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.  source  #  LightGraphs.DinicAlgorithm     Type .  DinicAlgorithm  : AbstractFlowAlgorithm  Forces the maximum_flow function to use Dinic's algorithm.  source  #  LightGraphs.EdmondsKarpAlgorithm     Type .  EdmondsKarpAlgorithm  : AbstractFlowAlgorithm  Forces the maximum_flow function to use the Edmonds\u2013Karp algorithm.  source  #  LightGraphs.PushRelabelAlgorithm     Type .  Forces the maximum_flow function to use the Push-Relabel algorithm.  source  #  LightGraphs.maximum_flow     Function .  maximum_flow(flow_graph, source, target[, capacity_matrix][, algorithm][, restriction])  Generic maximum_flow function for  flow_graph  from  source  to  target  with capacities in  capacity_matrix . Uses flow algorithm  algorithm  and cutoff restriction  restriction .   If  capacity_matrix  is not specified,  DefaultCapacity(flow_graph)  will be used.  If  algorithm  is not specified, it will default to  PushRelabelAlgorithm .  If  restriction  is not specified, it will default to  0 .   Return a tuple of (maximum flow, flow matrix). For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  Usage Example:  julia  flow_graph = DiGraph(8) # Create a flow-graph\njulia  flow_edges = [\n(1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n(2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n(5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\n\njulia  capacity_matrix = zeros(Int, 8, 8)  # Create a capacity matrix\n\njulia  for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u,v] = f\nend\n\njulia  f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow without the capacity_matrix\n\njulia  f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow with the capacity_matrix\n\njulia  f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm()) # Run Edmonds-Karp algorithm\n\njulia  f, F = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=DinicAlgorithm()) # Run Dinic's algorithm\n\njulia  f, F, labels = maximum_flow(flow_graph,1,8,capacity_matrix,algorithm=BoykovKolmogorovAlgorithm()) # Run Boykov-Kolmogorov algorithm  source  #  LightGraphs.ExtendedMultirouteFlowAlgorithm     Type .  ExtendedMultirouteFlowAlgorithm  Used to specify the Extended Multiroute Flow algorithm.  source  #  LightGraphs.KishimotoAlgorithm     Type .  KishimotoAlgorithm  Used to specify the Kishimoto algorithm.  source  #  LightGraphs.multiroute_flow     Method .  multiroute_flow(flow_graph, source, target[, DefaultCapacity][, flow_algorithm][, mrf_algorithm][, routes])  The generic multiroute_flow function.  The output will vary depending on the input:   When the number of  route s is  0 , return the set of breaking points of   the multiroute flow.   When the number of  route s is  1 , return a flow with a set of 1-disjoint paths   (this is the classical max-flow implementation).   When the input is limited to a set of breaking points and a route value  k ,   return only the k-route flow.   Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the   max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  When the input is a network, it requires the following arguments:   flow_graph : the input graph  source : the source vertex  target : the target vertex  capacity_matrix : matrix of edge flow capacities  flow_algorithm : keyword argument for flow algorithm  mrf_algorithm : keyword argument for multiroute flow algorithm  routes : keyword argument for the number of routes   When the input is only the set of (breaking) points and the number of route, it requires the following arguments:   breakingpoints : vector of breaking points  routes : number of routes   When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:   breakingpoints : vector of breaking points  routes : number of routes  flow_graph : the input graph  source : the source vertex  target : the target vertex  capacity_matrix : matrix of edge flow capacities  flow_algorithm : keyword argument for flow algorithm   The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of  1  is assumed for each link if no capacity matrix is provided.  The  mrf_algorithm  keyword is inforced to Extended Multiroute Flow in the following cases:   The number of routes is non-integer  The number of routes is 0 or non-specified   Usage Example :  (please consult the   max_flow  section for options about flow_algorithm and capacity_matrix)  julia  flow_graph = DiGraph(8) # Create a flow graph\n\njulia  flow_edges = [\n(1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n(2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n(5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\n\njulia  capacity_matrix = zeros(Int, 8, 8) # Create a capacity matrix\n\njulia  for e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\njulia  f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2) # Run default multiroute_flow with an integer number of routes = 2\n\njulia  f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5) # Run default multiroute_flow with a noninteger number of routes = 1.5\n\njulia  points = multiroute_flow(flow_graph, 1, 8, capacity_matrix) # Run default multiroute_flow for all the breaking points values\n\njulia  f, F = multiroute_flow(points, 1.5) # Then run multiroute flow algorithm for any positive number of routes\n\njulia  f = multiroute_flow(points, 1.5, valueonly = true)\n\njulia  f, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix, algorithm = BoykovKolmogorovAlgorithm(), routes = 2) # Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine  source", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/generators/", 
            "text": "Generators\n\n\n\n\nRandom Graphs\n\n\nLightGraphs.jl\n implements some common random graph generators:\n\n\n#\n\n\nLightGraphs.StochasticBlockModel\n \n \nType\n.\n\n\nStochasticBlockModel{T,P}\n\n\n\n\nA type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge \n(i,j)\n depends only on the block labels of vertex \ni\n and vertex \nj\n.\n\n\nThe assignement is stored in nodemap and the block affinities a \nk\n by \nk\n matrix is stored in affinities.\n\n\naffinities[k,l]\n is the probability of an edge between any vertex in block \nk\n and any vertex in block \nl\n.\n\n\nImplementation Notes\n\n\nGraphs are generated by taking random $i,j \u2208 V$ and flipping a coin with probability \naffinities[nodemap[i],nodemap[j]]\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert!\n \n \nMethod\n.\n\n\nbarabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)\n\n\n\n\nCreate a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph \ng\n. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert\n \n \nMethod\n.\n\n\nbarabasi_albert(n::Integer, n0::Integer, k::Integer)\n\n\n\n\nCreate a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph with \nn0\n vertices. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\ncomplete=false\n: if true, use a complete graph for the initial graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.barabasi_albert\n \n \nMethod\n.\n\n\nbarabasi_albert(n, k)\n\n\n\n\nCreate a \nBarab\u00e1si\u2013Albert model\n random graph with \nn\n vertices. It is grown by adding new vertices to an initial graph with \nk\n vertices. Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\ncomplete=false\n: if true, use a complete graph for the initial graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.blockcounts\n \n \nMethod\n.\n\n\nblockcounts(sbm, A)\n\n\n\n\nCount the number of edges that go between each block.\n\n\nsource\n\n\n#\n\n\nLightGraphs.erdos_renyi\n \n \nMethod\n.\n\n\nerdos_renyi(n, ne)\n\n\n\n\nCreate an \nErd\u0151s\u2013R\u00e9nyi\n random graph with \nn\n vertices and \nne\n edges.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.erdos_renyi\n \n \nMethod\n.\n\n\nerdos_renyi(n, p)\n\n\n\n\nCreate an \nErd\u0151s\u2013R\u00e9nyi\n random graph with \nn\n vertices. Edges are added between pairs of vertices with probability \np\n.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.make_edgestream\n \n \nMethod\n.\n\n\nmake_edgestream(sbm)\n\n\n\n\nTake an infinite sample from the Stochastic Block Model \nsbm\n. Pass to \nGraph(nvg, neg, edgestream)\n to get a Graph object based on \nsbm\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_configuration_model\n \n \nMethod\n.\n\n\nrandom_configuration_model(n, ks)\n\n\n\n\nCreate a random undirected graph according to the \nconfiguration model\n containing \nn\n vertices, with each node \ni\n having degree \nk[i]\n.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\ncheck_graphical=false\n: if true, ensure that \nk\n is a graphical sequence\n\n\n\n\n(see \nisgraphical\n).\n\n\nPerformance\n\n\nTime complexity is approximately $n \\bar{k}^2$.\n\n\nImplementation Notes\n\n\nAllocates an array of $n \\bar{k}$ \nInt\ns.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_regular_digraph\n \n \nMethod\n.\n\n\nrandom_regular_digraph(n, k)\n\n\n\n\nCreate a random directed \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nOptional Arguments\n\n\n\n\ndir=:out\n: the direction of the edges for degree parameter.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nImplementation Notes\n\n\nAllocates an $n \u00d7 n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\nsource\n\n\n#\n\n\nLightGraphs.random_regular_graph\n \n \nMethod\n.\n\n\nrandom_regular_graph(n, k)\n\n\n\n\nCreate a random undirected \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nPerformance\n\n\nTime complexity is approximately $nk^2$.\n\n\nImplementation Notes\n\n\nAllocates an array of \nnk\n \nInt\ns, and . For $k \n \\frac{n}{2}$, generates a graph of degree $n-k-1$ and returns its complement.\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_fitness_model\n \n \nMethod\n.\n\n\nstatic_fitness_model(m, fitness_out, fitness_in)\n\n\n\n\nGenerate a random graph with $|fitness_out + fitness_in|$ vertices and \nm\n edges, in which the probability of the existence of $Edge_{ij}$ is proportional with respect to $i \u221d fitness_out$ and $j \u221d fitness_in$.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_fitness_model\n \n \nMethod\n.\n\n\nstatic_fitness_model(m, fitness)\n\n\n\n\nGenerate a random graph with $|fitness|$ vertices and \nm\n edges, in which the probability of the existence of $Edge_{ij}$ is proportional to \n`fitness_i  \u00d7 fitness_j\n.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_scale_free\n \n \nMethod\n.\n\n\nstatic_scale_free(n, m, \u03b1_out, \u03b1_in)\n\n\n\n\nGenerate a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1_out\n for outbound edges and \n\u03b1_in\n for inbound edges.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\nfinite_size_correction=true\n: determines whether to use the finite size correction\n\n\n\n\nproposed by Cho et al.\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.static_scale_free\n \n \nMethod\n.\n\n\nstatic_scale_free(n, m, \u03b1)\n\n\n\n\nGenerate a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1\n.\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\nfinite_size_correction=true\n: determines whether to use the finite size correction\n\n\n\n\nproposed by Cho et al.\n\n\nPerformance\n\n\nTime complexity is $\\mathcal{O}(|V| + |E| log |E|)$.\n\n\nReferences\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.stochastic_block_model\n \n \nMethod\n.\n\n\nstochastic_block_model(c, n)\n\n\n\n\nReturn a Graph generated according to the Stochastic Block Model (SBM).\n\n\nc[a,b]\n : Mean number of neighbors of a vertex in block \na\n belonging to block \nb\n.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * \\frac{n[a]}{n[b]}$. \nn[a]\n : Number of vertices in block \na\n\n\nOptional Arguments\n\n\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nFor a dynamic version of the SBM see the \nStochasticBlockModel\n type and related functions.\n\n\nsource\n\n\n#\n\n\nLightGraphs.stochastic_block_model\n \n \nMethod\n.\n\n\nstochastic_block_model(cint, cext, n)\n\n\n\n\nReturn a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with $c_{a,a}=cint$, and $c_{a,b}=cext$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.watts_strogatz\n \n \nMethod\n.\n\n\nwatts_strogatz(n, k, \u03b2)\n\n\n\n\nReturn a \nWatts-Strogatz\n small model random graph with \nn\n vertices, each with degree \nk\n. Edges are randomized per the model based on probability \n\u03b2\n.\n\n\nOptional Arguments\n\n\n\n\nis_directed=false\n: if true, return a directed graph.\n\n\nseed=-1\n: set the RNG seed.\n\n\n\n\nsource\n\n\n\n\nStatic Graphs\n\n\nLightGraphs.jl\n also implements a collection of classic graph generators:\n\n\n#\n\n\nLightGraphs.BinaryTree\n \n \nMethod\n.\n\n\nBinaryTree(k::Integer)\n\n\n\n\nCreate a \nbinary tree\n of depth \nk\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CliqueGraph\n \n \nMethod\n.\n\n\nCliqueGraph(k, n)\n\n\n\n\nCreate a graph consisting of \nn\n connected \nk\n-cliques.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteBipartiteGraph\n \n \nMethod\n.\n\n\nCompleteBipartiteGraph(n1, n2)\n\n\n\n\nCreate an undirected \ncomplete bipartite graph\n with \nn1 + n2\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteDiGraph\n \n \nMethod\n.\n\n\nCompleteDiGraph(n)\n\n\n\n\nCreate a directed \ncomplete graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CompleteGraph\n \n \nMethod\n.\n\n\nCompleteGraph(n)\n\n\n\n\nCreate an undirected \ncomplete graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CycleDiGraph\n \n \nMethod\n.\n\n\nCycleDiGraph(n)\n\n\n\n\nCreate a directed \ncycle graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.CycleGraph\n \n \nMethod\n.\n\n\nCycleGraph(n)\n\n\n\n\nCreate an undirected \ncycle graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.DoubleBinaryTree\n \n \nMethod\n.\n\n\nBinaryTree(k::Integer)\n\n\n\n\nCreate a double complete binary tree with \nk\n levels.\n\n\nReferences\n\n\n\n\nUsed as an example for spectral clustering by Guattery and Miller 1998.\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.Grid\n \n \nMethod\n.\n\n\nGrid(dims; periodic=false)\n\n\n\n\nCreate a $|dims|$-dimensional cubic lattice, with length \ndims[i]\n in dimension \ni\n.\n\n\nOptional Arguments\n\n\n\n\nperiodic=false\n: If true, the resulting lattice will have periodic boundary\n\n\n\n\ncondition in each dimension.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PathDiGraph\n \n \nMethod\n.\n\n\nPathDiGraph(n)\n\n\n\n\nCreates a directed \npath graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.PathGraph\n \n \nMethod\n.\n\n\nPathGraph(n)\n\n\n\n\nCreate an undirected \npath graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.RoachGraph\n \n \nMethod\n.\n\n\nRoachGraph(k)\n\n\n\n\nCreate a Roach Graph of size \nk\n.\n\n\nReferences\n\n\n\n\nGuattery and Miller 1998\n\n\n\n\nsource\n\n\n#\n\n\nLightGraphs.StarDiGraph\n \n \nMethod\n.\n\n\nStarDiGraph(n)\n\n\n\n\nCreate a directed \nstar graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.StarGraph\n \n \nMethod\n.\n\n\nStarGraph(n)\n\n\n\n\nCreate an undirected \nstar graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.WheelDiGraph\n \n \nMethod\n.\n\n\nWheelDiGraph(n)\n\n\n\n\nCreate a directed \nwheel graph\n with \nn\n vertices.\n\n\nsource\n\n\n#\n\n\nLightGraphs.WheelGraph\n \n \nMethod\n.\n\n\nWheelGraph(n)\n\n\n\n\nCreate an undirected \nwheel graph\n with \nn\n vertices.\n\n\nsource\n\n\n\n\nSmall Graphs\n\n\nOther classical graphs can be generated by the following function:\n\n\n#\n\n\nLightGraphs.smallgraph\n \n \nMethod\n.\n\n\nsmallgraph(s)\nsmallgraph(s)\n\n\n\n\nCreate a small graph of type \ns\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron_dir\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n\n\nEuclidean Graphs\n\n\nGeneration of random and static graphs embedded in Euclidean space.\n\n\n#\n\n\nLightGraphs.euclidean_graph\n \n \nMethod\n.\n\n\neuclidean_graph(points)\n\n\n\n\nGiven the \nd\u00d7N\n matrix \npoints\n build an Euclidean graph of \nN\n vertices and return a graph and Dict containing the distance on each edge.\n\n\nOptional Arguments\n\n\n\n\nL=1\n: used to bound the \nd\n dimensional box from which points are selected.\n\n\np=2\n\n\nbc=:open\n\n\n\n\nImplementation Notes\n\n\nDefining the \nd\n-dimensional vectors \nx[i] = points[:,i]\n, an edge between vertices \ni\n and \nj\n is inserted if \nnorm(x[i]-x[j], p) \n cutoff\n. In case of negative \ncutoff\n instead every edge is inserted. For \np=2\n we have the standard Euclidean distance. Set \nbc=:periodic\n to impose periodic boundary conditions in the box $[0,L]^d$.\n\n\nsource\n\n\n#\n\n\nLightGraphs.euclidean_graph\n \n \nMethod\n.\n\n\neuclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGenerate \nN\n uniformly distributed points in the box $[0,L]^{d}$ and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points' positions.\n\n\nsource\n\n\n\n\nDatasets\n\n\nOther notorious graphs and integration with the \nMatrixDepot.jl\n package are available in the \nDatasets\n submodule of the companion package \nLightGraphsExtras.jl\n ```", 
            "title": "Graph Generators"
        }, 
        {
            "location": "/generators/#generators", 
            "text": "", 
            "title": "Generators"
        }, 
        {
            "location": "/generators/#random-graphs", 
            "text": "LightGraphs.jl  implements some common random graph generators:  #  LightGraphs.StochasticBlockModel     Type .  StochasticBlockModel{T,P}  A type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge  (i,j)  depends only on the block labels of vertex  i  and vertex  j .  The assignement is stored in nodemap and the block affinities a  k  by  k  matrix is stored in affinities.  affinities[k,l]  is the probability of an edge between any vertex in block  k  and any vertex in block  l .  Implementation Notes  Graphs are generated by taking random $i,j \u2208 V$ and flipping a coin with probability  affinities[nodemap[i],nodemap[j]] .  source  #  LightGraphs.barabasi_albert!     Method .  barabasi_albert!(g::AbstractGraph, n::Integer, k::Integer)  Create a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph  g . Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment.  Optional Arguments   seed=-1 : set the RNG seed.   source  #  LightGraphs.barabasi_albert     Method .  barabasi_albert(n::Integer, n0::Integer, k::Integer)  Create a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph with  n0  vertices. Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.  Optional Arguments   is_directed=false : if true, return a directed graph.  complete=false : if true, use a complete graph for the initial graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.barabasi_albert     Method .  barabasi_albert(n, k)  Create a  Barab\u00e1si\u2013Albert model  random graph with  n  vertices. It is grown by adding new vertices to an initial graph with  k  vertices. Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default.  Optional Arguments   is_directed=false : if true, return a directed graph.  complete=false : if true, use a complete graph for the initial graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.blockcounts     Method .  blockcounts(sbm, A)  Count the number of edges that go between each block.  source  #  LightGraphs.erdos_renyi     Method .  erdos_renyi(n, ne)  Create an  Erd\u0151s\u2013R\u00e9nyi  random graph with  n  vertices and  ne  edges.  Optional Arguments   is_directed=false : if true, return a directed graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.erdos_renyi     Method .  erdos_renyi(n, p)  Create an  Erd\u0151s\u2013R\u00e9nyi  random graph with  n  vertices. Edges are added between pairs of vertices with probability  p .  Optional Arguments   is_directed=false : if true, return a directed graph.  seed=-1 : set the RNG seed.   source  #  LightGraphs.make_edgestream     Method .  make_edgestream(sbm)  Take an infinite sample from the Stochastic Block Model  sbm . Pass to  Graph(nvg, neg, edgestream)  to get a Graph object based on  sbm .  source  #  LightGraphs.random_configuration_model     Method .  random_configuration_model(n, ks)  Create a random undirected graph according to the  configuration model  containing  n  vertices, with each node  i  having degree  k[i] .  Optional Arguments   seed=-1 : set the RNG seed.  check_graphical=false : if true, ensure that  k  is a graphical sequence   (see  isgraphical ).  Performance  Time complexity is approximately $n \\bar{k}^2$.  Implementation Notes  Allocates an array of $n \\bar{k}$  Int s.  source  #  LightGraphs.random_regular_digraph     Method .  random_regular_digraph(n, k)  Create a random directed  regular graph  with  n  vertices, each with degree  k .  Optional Arguments   dir=:out : the direction of the edges for degree parameter.  seed=-1 : set the RNG seed.   Implementation Notes  Allocates an $n \u00d7 n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.  source  #  LightGraphs.random_regular_graph     Method .  random_regular_graph(n, k)  Create a random undirected  regular graph  with  n  vertices, each with degree  k .  Optional Arguments   seed=-1 : set the RNG seed.   Performance  Time complexity is approximately $nk^2$.  Implementation Notes  Allocates an array of  nk   Int s, and . For $k   \\frac{n}{2}$, generates a graph of degree $n-k-1$ and returns its complement.  source  #  LightGraphs.static_fitness_model     Method .  static_fitness_model(m, fitness_out, fitness_in)  Generate a random graph with $|fitness_out + fitness_in|$ vertices and  m  edges, in which the probability of the existence of $Edge_{ij}$ is proportional with respect to $i \u221d fitness_out$ and $j \u221d fitness_in$.  Optional Arguments   seed=-1 : set the RNG seed.   Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.   source  #  LightGraphs.static_fitness_model     Method .  static_fitness_model(m, fitness)  Generate a random graph with $|fitness|$ vertices and  m  edges, in which the probability of the existence of $Edge_{ij}$ is proportional to  `fitness_i  \u00d7 fitness_j .  Optional Arguments   seed=-1 : set the RNG seed.   Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.   source  #  LightGraphs.static_scale_free     Method .  static_scale_free(n, m, \u03b1_out, \u03b1_in)  Generate a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1_out  for outbound edges and  \u03b1_in  for inbound edges.  Optional Arguments   seed=-1 : set the RNG seed.  finite_size_correction=true : determines whether to use the finite size correction   proposed by Cho et al.  Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  LightGraphs.static_scale_free     Method .  static_scale_free(n, m, \u03b1)  Generate a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1 .  Optional Arguments   seed=-1 : set the RNG seed.  finite_size_correction=true : determines whether to use the finite size correction   proposed by Cho et al.  Performance  Time complexity is $\\mathcal{O}(|V| + |E| log |E|)$.  References   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  LightGraphs.stochastic_block_model     Method .  stochastic_block_model(c, n)  Return a Graph generated according to the Stochastic Block Model (SBM).  c[a,b]  : Mean number of neighbors of a vertex in block  a  belonging to block  b .            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * \\frac{n[a]}{n[b]}$.  n[a]  : Number of vertices in block  a  Optional Arguments   seed=-1 : set the RNG seed.   For a dynamic version of the SBM see the  StochasticBlockModel  type and related functions.  source  #  LightGraphs.stochastic_block_model     Method .  stochastic_block_model(cint, cext, n)  Return a Graph generated according to the Stochastic Block Model (SBM), sampling from an SBM with $c_{a,a}=cint$, and $c_{a,b}=cext$.  source  #  LightGraphs.watts_strogatz     Method .  watts_strogatz(n, k, \u03b2)  Return a  Watts-Strogatz  small model random graph with  n  vertices, each with degree  k . Edges are randomized per the model based on probability  \u03b2 .  Optional Arguments   is_directed=false : if true, return a directed graph.  seed=-1 : set the RNG seed.   source", 
            "title": "Random Graphs"
        }, 
        {
            "location": "/generators/#static-graphs", 
            "text": "LightGraphs.jl  also implements a collection of classic graph generators:  #  LightGraphs.BinaryTree     Method .  BinaryTree(k::Integer)  Create a  binary tree  of depth  k .  source  #  LightGraphs.CliqueGraph     Method .  CliqueGraph(k, n)  Create a graph consisting of  n  connected  k -cliques.  source  #  LightGraphs.CompleteBipartiteGraph     Method .  CompleteBipartiteGraph(n1, n2)  Create an undirected  complete bipartite graph  with  n1 + n2  vertices.  source  #  LightGraphs.CompleteDiGraph     Method .  CompleteDiGraph(n)  Create a directed  complete graph  with  n  vertices.  source  #  LightGraphs.CompleteGraph     Method .  CompleteGraph(n)  Create an undirected  complete graph  with  n  vertices.  source  #  LightGraphs.CycleDiGraph     Method .  CycleDiGraph(n)  Create a directed  cycle graph  with  n  vertices.  source  #  LightGraphs.CycleGraph     Method .  CycleGraph(n)  Create an undirected  cycle graph  with  n  vertices.  source  #  LightGraphs.DoubleBinaryTree     Method .  BinaryTree(k::Integer)  Create a double complete binary tree with  k  levels.  References   Used as an example for spectral clustering by Guattery and Miller 1998.   source  #  LightGraphs.Grid     Method .  Grid(dims; periodic=false)  Create a $|dims|$-dimensional cubic lattice, with length  dims[i]  in dimension  i .  Optional Arguments   periodic=false : If true, the resulting lattice will have periodic boundary   condition in each dimension.  source  #  LightGraphs.PathDiGraph     Method .  PathDiGraph(n)  Creates a directed  path graph  with  n  vertices.  source  #  LightGraphs.PathGraph     Method .  PathGraph(n)  Create an undirected  path graph  with  n  vertices.  source  #  LightGraphs.RoachGraph     Method .  RoachGraph(k)  Create a Roach Graph of size  k .  References   Guattery and Miller 1998   source  #  LightGraphs.StarDiGraph     Method .  StarDiGraph(n)  Create a directed  star graph  with  n  vertices.  source  #  LightGraphs.StarGraph     Method .  StarGraph(n)  Create an undirected  star graph  with  n  vertices.  source  #  LightGraphs.WheelDiGraph     Method .  WheelDiGraph(n)  Create a directed  wheel graph  with  n  vertices.  source  #  LightGraphs.WheelGraph     Method .  WheelGraph(n)  Create an undirected  wheel graph  with  n  vertices.  source", 
            "title": "Static Graphs"
        }, 
        {
            "location": "/generators/#small-graphs", 
            "text": "Other classical graphs can be generated by the following function:  #  LightGraphs.smallgraph     Method .  smallgraph(s)\nsmallgraph(s)  Create a small graph of type  s . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :truncatedtetrahedron_dir  A skeleton of the  truncated tetrahedron digraph .    :tutte  A  Tutte graph .     source", 
            "title": "Small Graphs"
        }, 
        {
            "location": "/generators/#euclidean-graphs", 
            "text": "Generation of random and static graphs embedded in Euclidean space.  #  LightGraphs.euclidean_graph     Method .  euclidean_graph(points)  Given the  d\u00d7N  matrix  points  build an Euclidean graph of  N  vertices and return a graph and Dict containing the distance on each edge.  Optional Arguments   L=1 : used to bound the  d  dimensional box from which points are selected.  p=2  bc=:open   Implementation Notes  Defining the  d -dimensional vectors  x[i] = points[:,i] , an edge between vertices  i  and  j  is inserted if  norm(x[i]-x[j], p)   cutoff . In case of negative  cutoff  instead every edge is inserted. For  p=2  we have the standard Euclidean distance. Set  bc=:periodic  to impose periodic boundary conditions in the box $[0,L]^d$.  source  #  LightGraphs.euclidean_graph     Method .  euclidean_graph(N, d; seed=-1, L=1., p=2., cutoff=-1., bc=:open)  Generate  N  uniformly distributed points in the box $[0,L]^{d}$ and return a Euclidean graph, a map containing the distance on each edge and a matrix with the points' positions.  source", 
            "title": "Euclidean Graphs"
        }, 
        {
            "location": "/generators/#datasets", 
            "text": "Other notorious graphs and integration with the  MatrixDepot.jl  package are available in the  Datasets  submodule of the companion package  LightGraphsExtras.jl  ```", 
            "title": "Datasets"
        }, 
        {
            "location": "/persistence/", 
            "text": "Reading and writing Graphs\n\n\nGraphs may be written to I/O streams and files using the \nsave\n function and read with the \nload\n function. Currently supported graph formats are the  \nLightGraphs.jl\n format \nlg\n and the common formats \ngml, graphml, gexf, dot, net\n.\n\n\n#\n\n\nLightGraphs.load\n \n \nFunction\n.\n\n\nload(file, t=:lg)\n\n\n\n\nLoad multiple graphs from  \nfile\n in the format \nt\n. Return a dictionary mapping graph name to graph.\n\n\nFor unnamed graphs the default names \"graph\" and \"digraph\" will be used.\n\n\nsource\n\n\n#\n\n\nLightGraphs.load\n \n \nFunction\n.\n\n\nload(file, name, t=:lg)\n\n\n\n\nLoad a graph with name \nname\n from \nfile\n in format \nt\n.\n\n\nCurrently supported formats are \n:lg\n, \n:gml\n, \n:graphml\n, \n:gexf\n, \n:dot\n, \n:net\n, and \ngraph6\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.loadgraph\n \n \nMethod\n.\n\n\nloadgraph(file, t=:lg)\n\n\n\n\nRead a graph from  \nfile\n in the format \nt\n. Supported formats are \n:lg\n, \n:gml\n, \n:dot\n, \n:graphml\n, \n:gexf\n, \n:net\n, \n:jld\n, and \n:graph6\n.\n\n\nsource\n\n\n#\n\n\nLightGraphs.save\n \n \nFunction\n.\n\n\nsave(file, g, t=:lg)\nsave(file, g, name, t=:lg)\nsave(file, dict, t=:lg)\n\n\n\n\nSaves a graph \ng\n with name \nname\n to \nfile\n in the format \nt\n. If \nname\n is not given the default names \"graph\" and \"digraph\" will be used. Return the number of graphs written.\n\n\nCurrently supported formats are \n:lg\n, \n:gml\n, :\ngraphml\n, \n:gexf\n, \n:dot\n, \n:net\n, and \n:graph6\n.\n\n\nFor some graph formats, multiple graphs in a  \ndict\n \n\"name\"=\ng\n can be saved in the same file.\n\n\nsource\n\n\n#\n\n\nLightGraphs.savegraph\n \n \nMethod\n.\n\n\nsavegraph(f, g, ...)\n\n\n\n\nSave a graph to file. See \nsave\n.\n\n\nsource\n\n\n\n\nExamples\n\n\nsave(STDOUT, g)\nsave(\nmygraph.jgz\n, g, \nmygraph\n, compress=true)\n\nsavegraph(\nmygraph.jgz\n, g, compress=true)\n\ndg = load(\nmultiplegraphs.jgz\n) # dictionary of graphs\ndg = load(\nmultiplegraphs.graphml\n, :graphml)\ndg = load(\nmygraph.gml\n, \nmygraph\n, :gml)\n\ng = laoadgraph(\nmygraph.gml\n,  :gml)", 
            "title": "Reading / Writing Graphs"
        }, 
        {
            "location": "/persistence/#reading-and-writing-graphs", 
            "text": "Graphs may be written to I/O streams and files using the  save  function and read with the  load  function. Currently supported graph formats are the   LightGraphs.jl  format  lg  and the common formats  gml, graphml, gexf, dot, net .  #  LightGraphs.load     Function .  load(file, t=:lg)  Load multiple graphs from   file  in the format  t . Return a dictionary mapping graph name to graph.  For unnamed graphs the default names \"graph\" and \"digraph\" will be used.  source  #  LightGraphs.load     Function .  load(file, name, t=:lg)  Load a graph with name  name  from  file  in format  t .  Currently supported formats are  :lg ,  :gml ,  :graphml ,  :gexf ,  :dot ,  :net , and  graph6 .  source  #  LightGraphs.loadgraph     Method .  loadgraph(file, t=:lg)  Read a graph from   file  in the format  t . Supported formats are  :lg ,  :gml ,  :dot ,  :graphml ,  :gexf ,  :net ,  :jld , and  :graph6 .  source  #  LightGraphs.save     Function .  save(file, g, t=:lg)\nsave(file, g, name, t=:lg)\nsave(file, dict, t=:lg)  Saves a graph  g  with name  name  to  file  in the format  t . If  name  is not given the default names \"graph\" and \"digraph\" will be used. Return the number of graphs written.  Currently supported formats are  :lg ,  :gml , : graphml ,  :gexf ,  :dot ,  :net , and  :graph6 .  For some graph formats, multiple graphs in a   dict   \"name\"= g  can be saved in the same file.  source  #  LightGraphs.savegraph     Method .  savegraph(f, g, ...)  Save a graph to file. See  save .  source", 
            "title": "Reading and writing Graphs"
        }, 
        {
            "location": "/persistence/#examples", 
            "text": "save(STDOUT, g)\nsave( mygraph.jgz , g,  mygraph , compress=true)\n\nsavegraph( mygraph.jgz , g, compress=true)\n\ndg = load( multiplegraphs.jgz ) # dictionary of graphs\ndg = load( multiplegraphs.graphml , :graphml)\ndg = load( mygraph.gml ,  mygraph , :gml)\n\ng = laoadgraph( mygraph.gml ,  :gml)", 
            "title": "Examples"
        }, 
        {
            "location": "/integration/", 
            "text": "Integration with other packages\n\n\nLightGraphs.jl\n's integration with other Julia packages is designed to be straightforward. Here are a few examples.\n\n\n\n\nGraphs.jl\n\n\nCreating a Graphs.jl \nsimple_graph\n is easy:\n\n\njulia\n s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia\n for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end\n\n\n\n\n\n\nGraphLayout.jl\n\n\nThis excellent graph visualization package can be used with \nLightGraphs.jl\n as follows:\n\n\njulia\n g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia\n loc_x, loc_y = layout_spring_adj(am)\njulia\n draw_layout_adj(am, loc_x, loc_y, filename=\nwheel10.svg\n)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nTikzGraphs.jl\n\n\nAnother nice graph visualization package. (\nTikzPictures.jl\n required to render/save):\n\n\njulia\n g = WheelGraph(10); t = plot(g)\n\njulia\n save(SVG(\nwheel10.svg\n), t)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nGraphPlot.jl\n\n\nAnother graph visualization package that is very simple to use. \nCompose.jl\n is required for most rendering functionality:\n\n\njulia\n using GraphPlot, Compose\n\njulia\n g = WheelGraph(10)\n\njulia\n draw(PNG(\n/tmp/wheel10.png\n, 16cm, 16cm), gplot(g))\n\n\n\n\n\n\nMetis.jl\n\n\nThe Metis graph partitioning package can interface with \nLightGraphs.jl\n:\n\n\njulia\n using LightGraphs\n\njulia\n g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia\n partGraphKway(g, 6)  # 6 partitions\n\n\n\n\nNetworkViz.jl\n NetworkViz.jl is tightly coupled with \nLightGraphs.jl\n. Graphs can be visualized in 2D as well as 3D using \nThreeJS.jl\n and \nEscher.jl\n.\n\n\n#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets, \nwidgets\n)\n  push!(window.assets,(\nThreeJS\n,\nthreejs\n))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend\n\n\n\n\nThe above code produces the following output:", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#integration-with-other-packages", 
            "text": "LightGraphs.jl 's integration with other Julia packages is designed to be straightforward. Here are a few examples.", 
            "title": "Integration with other packages"
        }, 
        {
            "location": "/integration/#graphsjl", 
            "text": "Creating a Graphs.jl  simple_graph  is easy:  julia  s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))\njulia  for e in LightGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end", 
            "title": "Graphs.jl"
        }, 
        {
            "location": "/integration/#graphlayoutjl", 
            "text": "This excellent graph visualization package can be used with  LightGraphs.jl  as follows:  julia  g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia  loc_x, loc_y = layout_spring_adj(am)\njulia  draw_layout_adj(am, loc_x, loc_y, filename= wheel10.svg )  producing a graph like this:", 
            "title": "GraphLayout.jl"
        }, 
        {
            "location": "/integration/#tikzgraphsjl", 
            "text": "Another nice graph visualization package. ( TikzPictures.jl  required to render/save):  julia  g = WheelGraph(10); t = plot(g)\n\njulia  save(SVG( wheel10.svg ), t)  producing a graph like this:", 
            "title": "TikzGraphs.jl"
        }, 
        {
            "location": "/integration/#graphplotjl", 
            "text": "Another graph visualization package that is very simple to use.  Compose.jl  is required for most rendering functionality:  julia  using GraphPlot, Compose\n\njulia  g = WheelGraph(10)\n\njulia  draw(PNG( /tmp/wheel10.png , 16cm, 16cm), gplot(g))", 
            "title": "GraphPlot.jl"
        }, 
        {
            "location": "/integration/#metisjl", 
            "text": "The Metis graph partitioning package can interface with  LightGraphs.jl :  julia  using LightGraphs\n\njulia  g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia  partGraphKway(g, 6)  # 6 partitions", 
            "title": "Metis.jl"
        }, 
        {
            "location": "/integration/#networkvizjl-networkvizjl-is-tightly-coupled-with-lightgraphsjl-graphs-can-be-visualized-in-2d-as-well-as-3d-using-threejsjl-and-escherjl", 
            "text": "#Run this code in Escher\n\nusing NetworkViz\nusing LightGraphs\n\nmain(window) = begin\n  push!(window.assets,  widgets )\n  push!(window.assets,( ThreeJS , threejs ))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend  The above code produces the following output:", 
            "title": "NetworkViz.jl NetworkViz.jl is tightly coupled with LightGraphs.jl. Graphs can be visualized in 2D as well as 3D using ThreeJS.jl and Escher.jl."
        }, 
        {
            "location": "/contributing/", 
            "text": "We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.\n\n\n\n\nBug reports\n\n\nIf you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.\n\n\nPlease include version numbers of all relevant libraries and Julia itself.\n\n\n\n\nDevelopment guidelines\n\n\n\n\nPRs should contain one logical enhancement to the codebase.\n\n\nSquash commits in a PR.\n\n\nOpen an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\n\n\n\n\nMinimize dependencies on external packages, and avoid introducing new dependencies. In general,\n\n\n\n\nPRs introducing dependencies on core Julia packages are ok.\n\n\nPRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.\n\n\nPRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).\n\n\nPut type assertions on all function arguments (use abstract types, Union, or Any if necessary).\n\n\nIf the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).\n\n\nTake steps to ensure that code works on graphs with multiple connected components efficiently.\n\n\nCorrectness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.\n\n\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\n\n\nStyle point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (\ne.g.\n, \ncondition \n error(\"message\")\n is good; \ncondition \n i += 1\n is not).\n\n\nWhen possible write code to reuse memory. For example:\n\n\n\n\n\n\n\n\nfunction f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nshould be rewritten as two functions\n\n\nfunction f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractVector{Int}, g::AbstractGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nThis allows us to reuse the memory and improve performance.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#bug-reports", 
            "text": "If you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.  Please include version numbers of all relevant libraries and Julia itself.", 
            "title": "Bug reports"
        }, 
        {
            "location": "/contributing/#development-guidelines", 
            "text": "PRs should contain one logical enhancement to the codebase.  Squash commits in a PR.  Open an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).   Minimize dependencies on external packages, and avoid introducing new dependencies. In general,   PRs introducing dependencies on core Julia packages are ok.  PRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.  PRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).  Put type assertions on all function arguments (use abstract types, Union, or Any if necessary).  If the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).  Take steps to ensure that code works on graphs with multiple connected components efficiently.  Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.  We can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.  Style point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated ( e.g. ,  condition   error(\"message\")  is good;  condition   i += 1  is not).  When possible write code to reuse memory. For example:     function f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  should be rewritten as two functions  function f(g::AbstractGraph, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractVector{Int}, g::AbstractGraph, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  This allows us to reuse the memory and improve performance.", 
            "title": "Development guidelines"
        }, 
        {
            "location": "/license/", 
            "text": "The LightGraphs.jl package is licensed under the Simplified \"2-clause\" BSD License:\n\n\n\n\nCopyright (c) 2015: Seth Bromberger and other contributors.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nLightGraphs uses code derived from and/or inspired by the following packages:\n\n\nNetworkX:\n\n\n\n\nCopyright (C) 2004-2012, NetworkX Developers Aric Hagberg \n Dan Schult \n Pieter Swart \n All rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above with the distribution.\n\n\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nGraphs.jl:\n\n\n\n\nCopyright (c) 2012: John Myles White and other contributors.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License Information"
        }
    ]
}